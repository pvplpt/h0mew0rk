## Урок 1. Одномерные массивы. Базовые алгоритмы на массивах
### В практической работе есть:

Обязательные задачи помогут проверить, как вы усвоили материал модуля. Их нужно сдать на проверку куратору.
Дополнительные задачи подойдут тем, кто хочет ещё немного потренироваться, решая задачки по программированию. Вы также можете отправлять их на проверку и получать обратную связь куратора, хотя это необязательно.
Цели практической работы:

• Приобрести навыки работы с одномерными массивами различных типов.  
• Научиться работать с индексацией, в том числе проходом по циклу.  
• Найти и освоить некоторые алгоритмические подходы к работе с массивами.  
### Что входит в практическую работу

Обязательные задачи:
1. Многоквартирный дом.
2. Сортировка.
3. Использование assert.

Дополнительные задачи:  
4. Ряд чисел*.

### Задание 1. Многоквартирный дом

#### Что нужно сделать:
На вход программе поступают десять фамилий в формате строк. Это фамилии жильцов квартир с первой по десятую. Необходимо прочитать эти фамилии и записать в одномерный массив. Далее пользователь вводит три номера квартир. Необходимо вывести в консоль фамилию жильца, проживающего в этой квартире. Если пользователь введёт некорректный номер квартиры, необходимо сообщить ему об этом.

Пример:
```
← SidorovA
← IvanovA
← PetrovA
← SidorovB
← IvanovB
← PetrovB
← SidorovC
← IvanovC
← PetrovC
← SidorovD
←10
→SidorovD
←1
→SidorovA
←5
→IvanovB
```
#### Что оценивается:
• Используется массив строк для хранения данных.  
• В коде не используются библиотеки, кроме <iostream> и <string>.  
• Программа проверяет доступность элемента по индексу и выдаёт корректный результат.  

#### Задание 2. Сортировка

#### Что нужно сделать:
Пользователь вводит в консоль 15 дробных чисел. Необходимо прочитать их и вывести в консоль в порядке от большего к меньшему. По возможности используйте минимум дополнительной памяти и проходов по массиву.

Пример:
```
Ввод: 1.2 2.3 1.11 3.4 5.5 5.4 5.3 5.1 1.5 1.25 5.41 5.31 5.11 1.51 1.251
Вывод: 5.5 5.41 5.4 5.31 5.3 5.11 5.1 3.4 2.3 1.51 1.5 1.251 1.25 1.2 1.11
```
#### Рекомендации по выполнению
Воспользуйтесь дополнительными материалами.  
Об алгоритмах:  
• Описание алгоритмов сортировки и сравнение их производительности  
• Структуры данных: двоичная куча (binary heap)  
Подробнее о сложности и нотации большого O:  
• Оценка сложности алгоритмов, или Что такое О(log n)  
• Big O Notation: что это такое и как её посчитать  
• Big O. Оценка сложности алгоритмов  
Об алгоритмах сортировок, у которых сложность меньше O(n^2).  
HeapSort имеет сложность n*log(n):  
• Пирамидальная сортировка (HeapSort)  
• HeapSort  
MergeSort имеет сложность n*log(n):  
• Описание алгоритмов сортировки и сравнение их производительности  
• MergeSort  

#### Что оценивается:
• Используется массив чисел с плавающей точкой для хранения данных.  
• В коде не используются библиотеки, кроме <iostream>.  
• Программа корректно использует обращения по индексам и выдаёт правильный ответ.  
• Асимптотическая сложность алгоритма не более O(n^2).  
• Числа выводятся от большего к меньшему.  

### Задание 3. Использование assert

#### Что нужно сделать:
Создайте в своей программе функцию float travelTime(float distance, float speed). Она будет находить время в пути и при этом использовать assert, чтобы отбросить нулевую и отрицательную скорость. Вызовите эту функцию в main. Убедитесь, что падение происходит за счёт assert. Не забудьте подключить заголовочный файл cassert.

#### Что оценивается:
При запуске происходит падение с указанием исходника и строки в нём, на которой расположен вызов макроса assert.

#### Критерии оценки работы
• Программы запускаются и корректно работают, нет синтаксических ошибок.  
• Имена переменных корректные, отражают суть хранимых данных.  
• Создан текстовый интерфейс для всех программ.  
• Для всех заданий обеспечен контроль ввода, который обусловлен   логикой работы программы. Не должно быть обращения к элементам за границы контейнера хранения.  
• В решении программ соблюдается необходимая асимптотическая сложность.  

### Задание 4. Ряд чисел* (дополнительное задание)

#### Что нужно сделать:
В программе инициализирован массив из 15 целых положительных чисел. Эти числа являются множеством из 14 последовательных чисел, начиная с Х (Х может быть любым), а одно число из ряда повторяется. Необходимо найти повторяющееся число и вывести его в консоль. По возможности используйте минимум дополнительной памяти и проходов по массиву.

Пример:
```
int numbers[15] = {114, 111, 106, 107, 108, 105, 115, 108, 110, 109, 112, 113, 116, 117, 118}
В данном примере Х — это 105, а повторяющееся число — 108.
```
#### Рекомендации по выполнению
Это задание с подвохом. Подумайте, как его можно было бы легко решить за O(n). На всякий случай оставляем для вас подсказку. Рекомендуем воспользоваться при необходимости.

#### Что оценивается:
Используется массив int для хранения данных.  
В коде не используются библиотеки, кроме <iostream>.  
Программа корректно использует обращения по индексам и выдаёт правильный ответ.  
Асимптотическая сложность алгоритма менее O(n^2).  
### Как отправить работу на проверку

Пришлите для каждого задания ссылку на repl.it или файл .срр с решением через форму ниже.
