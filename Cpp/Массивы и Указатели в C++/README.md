# Массивы и Указатели в C++

## Урок 1. Одномерные массивы. Базовые алгоритмы на массивах

### В практической работе есть:

Обязательные задачи помогут проверить, как вы усвоили материал модуля. Их нужно сдать на проверку куратору.
Дополнительные задачи подойдут тем, кто хочет ещё немного потренироваться, решая задачки по программированию. Вы также можете отправлять их на проверку и получать обратную связь куратора, хотя это необязательно.
Цели практической работы:

• Приобрести навыки работы с одномерными массивами различных типов.  
• Научиться работать с индексацией, в том числе проходом по циклу.  
• Найти и освоить некоторые алгоритмические подходы к работе с массивами.

### Что входит в практическую работу

Обязательные задачи:

1. Многоквартирный дом.
2. Сортировка.
3. Использование assert.

Дополнительные задачи:  
4. Ряд чисел\*.

### Задание 1. Многоквартирный дом

#### Что нужно сделать:

На вход программе поступают десять фамилий в формате строк. Это фамилии жильцов квартир с первой по десятую. Необходимо прочитать эти фамилии и записать в одномерный массив. Далее пользователь вводит три номера квартир. Необходимо вывести в консоль фамилию жильца, проживающего в этой квартире. Если пользователь введёт некорректный номер квартиры, необходимо сообщить ему об этом.

Пример:

```
← SidorovA
← IvanovA
← PetrovA
← SidorovB
← IvanovB
← PetrovB
← SidorovC
← IvanovC
← PetrovC
← SidorovD
←10
→SidorovD
←1
→SidorovA
←5
→IvanovB
```

#### Что оценивается:

• Используется массив строк для хранения данных.  
• В коде не используются библиотеки, кроме <iostream> и <string>.  
• Программа проверяет доступность элемента по индексу и выдаёт корректный результат.

#### Задание 2. Сортировка

#### Что нужно сделать:

Пользователь вводит в консоль 15 дробных чисел. Необходимо прочитать их и вывести в консоль в порядке от большего к меньшему. По возможности используйте минимум дополнительной памяти и проходов по массиву.

Пример:

```
Ввод: 1.2 2.3 1.11 3.4 5.5 5.4 5.3 5.1 1.5 1.25 5.41 5.31 5.11 1.51 1.251
Вывод: 5.5 5.41 5.4 5.31 5.3 5.11 5.1 3.4 2.3 1.51 1.5 1.251 1.25 1.2 1.11
```

#### Рекомендации по выполнению

Воспользуйтесь дополнительными материалами.  
Об алгоритмах:  
• Описание алгоритмов сортировки и сравнение их производительности  
• Структуры данных: двоичная куча (binary heap)  
Подробнее о сложности и нотации большого O:  
• Оценка сложности алгоритмов, или Что такое О(log n)  
• Big O Notation: что это такое и как её посчитать  
• Big O. Оценка сложности алгоритмов  
Об алгоритмах сортировок, у которых сложность меньше O(n^2).  
HeapSort имеет сложность n*log(n):  
• Пирамидальная сортировка (HeapSort)  
• HeapSort  
MergeSort имеет сложность n*log(n):  
• Описание алгоритмов сортировки и сравнение их производительности  
• MergeSort

#### Что оценивается:

• Используется массив чисел с плавающей точкой для хранения данных.  
• В коде не используются библиотеки, кроме <iostream>.  
• Программа корректно использует обращения по индексам и выдаёт правильный ответ.  
• Асимптотическая сложность алгоритма не более O(n^2).  
• Числа выводятся от большего к меньшему.

### Задание 3. Использование assert

#### Что нужно сделать:

Создайте в своей программе функцию float travelTime(float distance, float speed). Она будет находить время в пути и при этом использовать assert, чтобы отбросить нулевую и отрицательную скорость. Вызовите эту функцию в main. Убедитесь, что падение происходит за счёт assert. Не забудьте подключить заголовочный файл cassert.

#### Что оценивается:

При запуске происходит падение с указанием исходника и строки в нём, на которой расположен вызов макроса assert.

#### Критерии оценки работы

• Программы запускаются и корректно работают, нет синтаксических ошибок.  
• Имена переменных корректные, отражают суть хранимых данных.  
• Создан текстовый интерфейс для всех программ.  
• Для всех заданий обеспечен контроль ввода, который обусловлен логикой работы программы. Не должно быть обращения к элементам за границы контейнера хранения.  
• В решении программ соблюдается необходимая асимптотическая сложность.

### Задание 4. Ряд чисел\* (дополнительное задание)

#### Что нужно сделать:

В программе инициализирован массив из 15 целых положительных чисел. Эти числа являются множеством из 14 последовательных чисел, начиная с Х (Х может быть любым), а одно число из ряда повторяется. Необходимо найти повторяющееся число и вывести его в консоль. По возможности используйте минимум дополнительной памяти и проходов по массиву.

Пример:

```
int numbers[15] = {114, 111, 106, 107, 108, 105, 115, 108, 110, 109, 112, 113, 116, 117, 118}
В данном примере Х — это 105, а повторяющееся число — 108.
```

#### Рекомендации по выполнению

Это задание с подвохом. Подумайте, как его можно было бы легко решить за O(n). На всякий случай оставляем для вас подсказку. Рекомендуем воспользоваться при необходимости.

#### Что оценивается:

Используется массив int для хранения данных.  
В коде не используются библиотеки, кроме <iostream>.  
Программа корректно использует обращения по индексам и выдаёт правильный ответ.  
Асимптотическая сложность алгоритма менее O(n^2).

### Как отправить работу на проверку

Пришлите для каждого задания ссылку на repl.it или файл .срр с решением через форму ниже.

## Урок 2. Знакомство с std::vector v2

### Практическая работа

### Цель практической работы:

• Научиться работать с типом std::vector.  
• Попробовать на практике использовать функции для работы с vector.

### Задача 1

#### Что нужно сделать

Необходимо из заданного пользователем вектора удалить число X.

Как работает программа

1. Пользователь вводит с клавиатуры число n — размер вектора, который надо заполнять.
2. Пользователь вводит n целых чисел, которые заполняют вектор.
3. Пользователь вводит значение — X. X — удаляемое из вектора значение. Необходимо удалить из вектора все элементы, которые равны заданному значению.
4. В конце программы необходимо вывести итоговое состояние вектора.

Пример выполнения

```
Input vector size: 5
Input numbers: 1 3 3 5 1
Input number to delete: 3
Result: 1 5 1
```

Пояснение  
Пользователь ввёл 5, потом числа 1, 3, 3, 5, 1 и потом число 3. В векторе должны остаться числа 1, 5, 1, которые надо вывести на экран.

#### Что оценивается

• Не удалено лишних элементов.  
• Все элементы, которые необходимо удалить, удалены.  
• Для удаления элементов из вектора использована функция pop_back()  
• Удаления из вектора совершены in-place, т.е. при удалении из вектора не используются дополнительные структуры данных или переменные.  
• Решение использует только один вектор.

### Задача 2

#### Что нужно сделать

С помощью списка инициализации задаётся вектор цен на продукты (дробными
числами). Таким же образом с помощью списка инициализации задаётся вектор покупок (в виде индексов), которые совершает человек. Необходимо вывести на экран итоговую стоимость покупок. Вектор цен и вектор покупок можно задать напрямую в коде.

Пример выполнения

```
// Вектор цен выглядит так: {2.5, 4.25, 3.0, 10.0}.
std::vector<float> prices {2.5, 4.25, 3.0, 10.0};
// Вектор покупок: {1, 1, 0, 3}, то есть два товара по индексу 1 и по одному — индексов 0 и 3.
std::vector<int> items {1, 1, 0, 3};

Суммарная стоимость будет равна 21.0.
```

#### Советы и рекомендации

При получении итоговой стоимости покупок не нужно делать циклы по обоим векторам, достаточно одного цикла.

#### Что оценивается

Программа не допускает выхода за границы вектора цен.

### Задача 3

#### Что нужно сделать

Вам дали задание разработать хранилище для целочисленных значений во встраиваемой операционной системе. Такие системы работают в большей части техники, которая нас окружает: автомобилях, стиральных машинах, микроволновках, холодильниках. Только вот незадача: объём памяти этой системы очень небольшой, поэтому в хранилище не может находиться более 20 элементов.
В хранилище, являющееся вектором, с клавиатуры приходят целочисленные значения и помещаются один за другим.
При вводе «−1» с клавиатуры необходимо вывести всё содержимое хранилища (20 или менее элементов). При выводе элементы должны быть в том порядке, в котором они добавлялись.
Попробуйте написать максимально оптимизированное решение этой задачи, чтобы совершалось как можно меньше расширений и перемещений элементов внутри вектора.
Чтобы задать размера вектора равным 20, используйте:

```
std::vector<int> db(20);
// ^ Задаём размер вектора при создании
```

Пример выполнения:

```
input number: 1
input number: 2
input number: 3
…
input number: 19
input number: 20
input number: -1
output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
input number: 21
input number: 22
input number: 23
input number: -1
output: 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
```

#### Рекомендации по выполнению

Посмотрите, как работает кольцевой буфер. Этот алгоритм поможет быстрее найти решение.

#### Что оценивается

• Размер вектора не превышает 20 элементов.  
• Нет изменений в размере вектора (это выполняется, если вы выбрали верный алгоритм решения).

### Критерии оценки

• Выполнены все три задания.  
• Программы запускаются и корректно работают, нет синтаксических ошибок.  
• Имена переменных корректные, отражают суть хранимых данных.  
• Создан текстовый интерфейс для всех программ.  
• Для всех задач обеспечен контроль ввода.  
• В циклах нет выхода за границы векторов.

### Как отправить работу на проверку

В форме ниже прикрепите ссылки на ваши проекты в repl.it, по одной на каждое задание.

## Урок 3. Двумерные массивы и алгоритмы над ними

### В практической работе есть:

Обязательные задачи помогут проверить, как вы усвоили материал модуля. Их нужно сдать на проверку куратору.
Дополнительные задачи подойдут тем, кто хочет ещё немного потренироваться, решая задачки по программированию. Вы также можете отправлять их на проверку и получать обратную связь куратора, хотя это необязательно.

### Цели практической работы

Научиться пользоваться двумерными массивами.
Освоить инициализацию и индексацию двумерных массивов.
Попробовать на практике алгоритмы и функции с двумерными массивами.

### Что входит в практическую работу

Обязательные задачи:

1. Банкетный стол.
2. Крестики-нолики
3. Матрицы
4. Умножение матрицы на вектор
5. Пупырка

Дополнительные задачи:  
6. Проход змейкой*.  
7. Почти «Майнкрафт*  
8. Морской бой\*

### Задание 1. Банкетный стол

#### Что нужно сделать

По поводу успешного прохождения двумерных массивов собирается банкет, организуется стол на 12 персон. Есть два VIP-места, они рядом во главе стола. Стол протяжён в длину, места расположены в два ряда. Каждый пришедший должен быть «упакован» соответствующим образом. Во-первых, столовые приборы: по три на каждого человека (вилка, ложка, нож) и одна маленькая дополнительная ложечка для VIP-персон (для десерта). Во-вторых, тарелки: каждому по две (для первого и второго блюда) и ещё одна тарелка для VIP-персон (для десерта). В-третьих, стулья: минимум один для каждого гостя. Заведите соответствующие двумерные массивы для количества приборов, посуды и стульев и проинициализируйте их.
Но это ещё не всё. На банкете после инициализации происходят некоторые события. Пришедшая на пятое место первого ряда дама привела с собой ребёнка, и поэтому на данное место был приставлен ещё один стул. С третьего места во втором ряду в неизвестном направлении была украдена ложка. Одна из VIP-персон (любая) поделилась своей ложкой с тем, кто остался без ложки, и стала есть суп десертной. За ненадобностью официант забрал у VIP-гостя одну десертную тарелку, ведь есть десерт ложкой, которая уже побывала уже в супе, неприлично. Больше без происшествий, однако эти события на банкете надо отразить в инициализированных ранее массивах.

#### Советы и рекомендации

• Все действия в задаче оформляются в виде выражений внутри исходного кода. Текстовый интерфейс для задачи делать необязательно.  
• Необходимо объявить несколько двумерных массивов (по типам приборов).  
• Массивы очень удобно инициализировать сразу при объявлении так:  
int packages[2][3] = {{2, 1, 7},{3, 5, 31}}  
• Проще будет сначала записать в массивы значения из задания, а потом отнимать или прибавлять нужные элементы, следуя за сценарием событий:  
packages[0][0] +=1; // packages[0][0] хранит в себе цифру 2, и мы прибавляем к этому значению 1 — += 1.

#### Что оценивается

Все действия внутри массива соответствуют условию.

### Задание 2. Крестики-нолики

#### Что нужно сделать

Старая добрая игра на страницах всех школьных тетрадей. Поле размером 3 × 3 представлено в виде двумерного массива с типом элементов char. Участвуют два игрока, они ходят по очереди и ставят в указанные ими в стандартном вводе координаты свой символ — X или O (буквы латинского алфавита). Как только у одного из игроков будет установлено подряд три крестика или три нолика, он побеждает. Если свободных клеток не осталось, а трёх совпадающих элементов не найдено, то объявляется ничья. Для простоты не будем рассматривать диагональные совпадения — только строго вертикальные и строго горизонтальные.  
Изначально всё поле инициализируется символом пробела — ‘ ‘(для обозначения пробела кавычки одинарные и в одну сторону). Это можно сделать сразу при объявлении либо с помощью вложенного цикла. На каждом ходе при занятой клетке или при неверных координатах этой клетки должно быть выведено сообщение, и игрок должен указать координаты клетки повторно. После каждого хода надо выводить в консоль текущее состояние всего игрового поля для наглядности.

#### Советы и рекомендации

• Действия для обоих игроков одинаковые, отличаются только символом, который ставится на поле.  
• Игровой цикл не должен быть бесконечным. Игра имеет определённое максимальное количество шагов.  
• Не забывайте про случай ничьей.  
• Как и в предыдущем задании, здесь будет удобно сразу заполнить массив значениями false. Количество мест, доступных для заполнения, заранее известно. В процессе заполнения из этой переменой нужно не забывать вычитать единицу. Чтобы отметить место как занятое, нужно лишь написать places[i][j] = true;.  
• Проверку на победу игрока, которую надо осуществлять после каждого хода, можно сделать с помощью вложенного цикла, сразу проверяя и вертикаль, и горизонталь, а как именно — попробуйте догадаться сами.  
• Здесь заранее известно число ходов — 3 \* 3. Столько раз должен быть выполнен цикл, который спрашивает у очередного игрока координаты.  
• Символ, который будет установлен в указанных координатах, можно на каждом шаге менять подобным образом:

```
if (gamer_name == 'X')
gamer_name = 'O';
else
gamer_name = 'X';
```

#### Что оценивается

• Корректный ход игры, соответствующий правилам.  
• Правильный (желательно красивый) вывод игрового поля.  
• Понятный игроку интерфейс.

### Задание 3. Матрицы

Требуется реализовать небольшую программу для сравнения двух двумерных матриц размером 4 × 4 на предмет их полного равенства. Если матрицы равны друг другу, необходимо взять одну из матриц и привести её к диагональному виду. Программа принимает на вход две целочисленные матрицы A и B, которые вводятся с помощью std::cin, и сравнивает их на предмет полного равенства. Если матрицы равны, то об этом сообщается в стандартном выводе. Алгоритм должен быть по возможности оптимальным и не проводить лишних операций. Если матрицы не равны, выводится соответствующее сообщение и выполнение программы прекращается. Если матрицы равны, то из них выбирается одна и преобразуется в диагональную. Конвертация в диагональную форму делается путём простейшего зануления всех элементов, лежащих вне главной диагонали. Напомню, что диагональная матрица — это такая матрица, у которой все элементы вне диагонали равны нулю. Диагональ матрицы, в свою очередь, — это все элементы, расположенные по диагонали от первого элемента первой строки до последнего элемента последней строки. Итоговую диагональную матрицу можно расположить на месте прежней матрицы, не используя дополнительных переменных. Результат преобразования требуется вывести в консоль для проверки. Ищите именно оптимальное решение, оно довольно простое.

#### Советы и рекомендации

• Чтобы не производить лишних вычислений, стоит при первом же расхождении значений в соответствующих ячейках завершить алгоритм.  
• Если хотя бы один элемент матриц не совпадает, можно сразу останавливать проверку.  
• Чтобы в результате получить диагональную матрицу, достаточно пройти по каждому элементу массива и занулить его, если строка не равна столбцу.  
• Достаточно привести матрицу к диагональному виду. Делать алгоритмическое преобразование не нужно.  
• Сравнение матриц и приведение матрицы к диагональному виду лучше оформить в виде отдельных функций.

#### Что оценивается

Программа корректно сравнивает две матрицы и в случае совпадения формирует диагональную матрицу.

### Задание 4. Умножение матрицы на вектор

Реализуйте частный случай умножения матрицы на матрицу, а именно умножение вектора на матрицу. Эта операция распространена в компьютерной индустрии в целом и в компьютерной графике в частности, поэтому это будет хорошим упражнением.
Итак, у нас есть четырёхкомпонентный вектор b, представленный с помощью массива, и матрица a размером 4 × 4, представленная в виде двумерного массива. Их произведением будет новый четырёхэлементный вектор c. Его компоненты будут суммой произведений элемента вектора b на строку матрицы a. Индекс столбца при этом равен индексу соответствующей компоненты вектора b, который мы и рассчитываем.
Все входные данные, матрица a и вектор b вносятся из пользовательского ввода. Итоговый вектор c надо вывести в консоль (std::cout). Тип данных элементов — всегда float. Желательно реализовать этот алгоритм с помощью вложенного цикла на умножение колонки.

#### Советы и рекомендации

Во внутреннем цикле потребуется аккумулятор, накапливающий значение очередной ячейки результирующего вектора. Каждый раз не забывайте его обнулять до начала расчётов.

#### Что оценивается

Программа вычисляет результирующий вектор в соответствии с формулой перемножения матрицы на вектор.

### Задание 5. Пупырка

После посылки из Китая осталась спецплёнка для бережной перевозки груза — пупырка. Всего в пупырке 12 на 12 шариков-пузырьков. Состояние любого пузырька: он либо целый, либо нет, то есть true или false (тип массива — bool). Для начала требуется реализовать отдельную функцию инициализации пупырки начальным состоянием: полностью целая пупырка, все элементы true.  
Программа заключается в последовательном лопании целых регионов пузырьков. Перед каждым таким лопанием надо показывать пользователю полностью всю плёнку: o — это целый пузырёк, x — лопнутый. Это тоже надо выделить в отдельную функцию. Итак, как выглядит само лопание. Пользователь вводит две координаты: начала региона и конца региона. Процедура лопания пузырей должна быть реализована с помощью отдельной функции, все аргументы должны проверяться на валидность, что они в в рамках диапазона возможных значений, иначе должна быть выведена ошибка. После лопания каждого пузыря, который не был ещё лопнут до того, в консоль должно выводиться сообщение “Pop!”.  
Лопание должно продолжаться до последнего пузырька. Как только вся пупырка потрачена, программа заканчивает выполнение. Вы можете подсчитать окончание в самой функции по отображению пузырьков плёнки, так как функция выполняется после каждого лопания.

#### Советы и рекомендации

• Обратите внимание, что лопание пузырей делается с помощью региона, а не одной точки.  
• Регион задаётся двумя координатами, это координаты углов прямоугольника.  
• При лопании региона достаточно запустить цикл только по этим элементам. Не нужно проходить каждый раз по всей матрице.  
• Всю область плёнки удобно представить в виде двумерного массива типа bool.  
• Инициализировать вручную такой массив сложно, лучше воспользоваться вложенными циклами.  
• Для проверки на целостность одной ячейки (если вы используете тип bool) можно не сравнивать её с истиной, а указать в условии имя переменной.  
Например, вместо:

```
if (shell[i][j] == true)
{
…
}
```

Достаточно записать:

```
if (shell[i][j])
{
…
}
```

Такой трюк можно проделывать с переменными типа bool.

#### Что оценивается

• Программа заканчивает выполнение только после того, как не осталось целых пузырей.  
• Лопание пузырей производится с помощью прямоугольной области.

### Задание 6. Проход змейкой (дополнительное задание)

Есть двумерный массив целых чисел размером 5 на 5 элементов. Его надо инициализировать и отобразить на экране. Особенность именно в способе этой инициализации. Элементы должны быть инициализированы не последовательно, а змейкой: в конце каждой строки мы должны не переходить к первому элементу следующей строки, а начать наоборот, с последнего элемента и так далее. В конечном отображении массива числа должны быть упорядочены по возрастанию, но змеевидно от строке к строке. Сама же последовательность чисел — это простое линейное возрастание от 0 до 24, для её учёта можно завести отдельную переменную.  
Попытайтесь решить эту задачу используя минимальное количество временных переменных и без условных переходов if. Если вы найдёте формулу индексации, будет замечательно! Она может быть весьма витиеватой..

#### Советы и рекомендации

Результирующий массив должен выглядеть так:

```
0 1 2 3 4
9 8 7 6 5
10 11 12 13 14
19 18 17 16 15
20 21 22 23 24
```

Внешний и внутренний циклы идут от 0 до 5, тут ничего нового. Первый индекс (строка) тоже без сюрпризов: это значение счётчика внешнего цикла:

```
for (int i = 0; i < 5; ++i) {
for (int j = 0; j < 5; ++j) {
digits[i][...] = number;
number += 1;
}
…
}
```

Самое сложное тут — это номер столбца. Чтобы сначала двигаться слева направо, а на следующей строке наоборот, стоит завести переменную-множитель, которая на чётных строках будет равна 1. На нечётных строках меняет знак: multiplier \*= −1;

#### Что оценивается

В решении не используются условные конструкции.

### Задание 7. Почти «Майнкрафт» (дополнительное задание)

Нам предстоит сделать некое подобие «Майнкрафта». Миллионов не обещаю, но это интересная задача на пространственное мышление. У нас есть небольшой квадратный ландшафт, размером 5 × 5 секторов. В каждом секторе располагается блок (столбик) ландшафта, максимальная высота которого — 10 блоков. Текущая высота каждого такого блока задаётся пользователем в начале программы. Итоговая задача: используя трёхмерный массив, вывести в стандартный вывод горизонтальное сечение (или горизонтальный срез) нашего небольшого мира. Сам мир как раз должен быть представлен в виде трёхмерного массива. Его горизонтальный срез — это двумерный массив, который надо отобразить в виде единиц и нулей. 0 — это отсутствие элемента на данном уровне в данной точке, 1 — элемент есть. Уровень среза от 0 до 9 включительно также задаётся в стандартном вводе.

Пример выполнения

```
input matrix of heights:
5 5 5 5
4 4 4 4
3 2 2 3
1 1 1 1
input slice: 4
1 1 1 1
1 1 1 1
0 0 0 0
0 0 0 0
input slice: 3
1 1 1 1
1 1 1 1
1 0 0 1
0 0 0 0
```

Пояснение к примеру

#### Что оценивается

• Использован трёхмерный массив.  
• Пользователь задаёт срез ландшафта, который хочет увидеть (от 0 до 9).  
• Выводится срез размером 5 × 5, состоящий из 0 и 1.

#### Советы и рекомендации

При печати потребуется проверять содержимое трёхмерного массива. При уже известном значении уровня level проверка выглядит так:

```
if (world[i][j][level])
{
//печатаем 1
}
else
{
//печатаем 0
}
```

### Задание 8. Морской бой (дополнительное задание)

Требуется реализовать упрощённую игру в морской бой. Игровое поле размером 10 на 10 клеток. Участвуют два игрока. В арсенале каждого из них 4 маленьких кораблика размером в одну клетку, 3 небольших корабля размером в две клетки, 2 средних корабля размером в три клетки и один большой корабль размером в четыре клетки. Для простоты клетки поля пронумерованы по вертикали от 0 до 9 и по горизонтали от 0 до 9. Мы не будем использовать классические наименования клеток, такие как B4, C6, а просто два индекса. Вначале игроки по очереди расставляют корабли, начиная с самых маленьких и заканчивая большими. Маленькие корабли в одну клетку расставляются с помощью указания одной клетки-точки на поле, к примеру 2,1. Корабли размерностью от двух клеток и выше расставляются с помощью координат их начала и конца, к примеру: 0,1–0,3. Корабли могут быть установлены только строго вертикально или горизонтально. Установка корабля по диагонали недопустима, об этом тоже надо сообщить пользователю. Если корабль не может быть размещён на заданных клетках из-за того, что он столкнётся с другим кораблём (окажется на его клетках) или выйдет за пределы поля, то игроку должно быть сделано предупреждение, после которого он должен переставить корабль на новые валидные координаты. В нашем упрощённом варианте игры мы не будем обсчитывать соприкосновения кораблей друг с другом, а потому корабли вполне можно будет размещать друг к другу вплотную, борт к борту. После того как все корабли расставлены, начинается игра. Игроки по очереди атакуют друг друга, называя координаты выстрела. После выстрела в консоль выводится информация о его результате: попал или мимо. Если выстрел успешен, клетка, на которой был корабль (или его фрагмент), затирается и становится пустой. Игра заканчивается тогда, когда все корабли одной из сторон будут полностью уничтожены. Как только это произойдёт, в консоль выводится информация с номером игрока, который победил.

#### Советы и рекомендации

Действия игроков практически одинаковые, их можно объединить в функции.
В программе достаточно иметь два поля, по одному на каждого игрока.
Лучше создать три отдельные функции: одну для размещения одного корабля, еще одну как обёртку над первой (она будет размещать все корабли), а третью для удара по координате. Также вам потребуются два глобальных массива для двух отдельных участков моря:

```
bool field_1[10][10];
bool field_2[10][10];
```

#### Что оценивается

• Корабли расставляются правильно.  
• Есть возможность выиграть.  
• Реализован понятный и удобный для пользователя интерфейс игры.

### Критерии оценки

1. В циклах нет выхода за границы массивов.
2. Все повторяющиеся действия вынесены в функции.
3. Программы запускаются и корректно работают, нет синтаксических ошибок.
4. Имена переменных корректные, отражают суть хранимых данных.
5. Создан текстовый интерфейс для всех программ, кроме первой.
6. Обеспечен контроль ввода, где это необходимо.
7. Выполнено пять заданий и более.

### Как отправить работу на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи практической работы.

## Урок 4. Алгоритмы на массивах

### Цели практической работы

• Попробовать на практике алгоритмы поиска в массиве.  
• Изучить основные алгоритмы сортировки массивов.

### Задача 1

#### Что нужно сделать:

Вам даётся массив целых чисел. Необходимо найти такие два индекса i и j в этом массиве, что сумма a[i], a[i+1], a[i+2], … a[j] будет максимально возможной и вывести их.  
a = {-2,1,-3,4,-1,2,1,-5,4}  
Тогда наибольшая сумма последовательных элементов находится между индексами 3 и 6: {4,-1,2,1}, сумма = 6. Необходимо вывести 3 и 6.

### Задача 2

#### Что нужно сделать:

Вам даётся массив целых чисел и одно число — результат. Необходимо найти в массиве два числа, сумма которых будет давать результат, и вывести их на экран. Гарантируется, что только одна пара чисел в массиве даёт в сумме результат.  
Пример:

```
a = {2, 7, 11, 15}. Результат = 9
2 + 7 = 9, так что надо вывести числа 2 и 7
```

#### Советы и рекомендации:

Как только найдена первая удовлетворяющая условиям пара, можно заканчивать поиск.

### Задача 3

#### Что нужно сделать:

С клавиатуры вводятся числа. Когда пользователь вводит «-1», необходимо выводить на экран пятое по возрастанию число среди введённых. Когда пользователь вводит «-2», программа завершает работу.

Пример:

```
ввод: 7 5 3 1 2 4 6 -1
вывод: 5 (в отсортированном виде массив выглядит так: {1,2,3,4,5,6,7})
ввод: 1 1 1 -1
вывод: 2 (в отсортированном виде массив выглядит так: {1,1,1,1,2,3,4,5,6,7})
ввод -2
завершение программы
```

#### Советы и рекомендации:

Нужно удостовериться, что можно вывести требуемое число (может быть меньше пяти чисел).

### Задача 4

#### Что нужно сделать:

Вам даётся массив целых чисел, отсортированных по возрастанию. Необходимо вывести его на экран отсортированным в порядке возрастания модуля чисел.  
Пример:

```
Массив {-100,-50, -5, 1, 10, 15}
Вывод: 1, -5, 10, 15, -50, -100
```

#### Советы и рекомендации:

Положительные числа уже отсортированы в порядке возрастания модулей.

## Критерии оценки:

1. В циклах нет выхода за границы массивов.
2. Вывод ошибок должен производиться в поток вывода ошибок std::cerr.
3. Действия должны быть вынесены в функции.
4. Программы запускаются и корректно работают, нет синтаксических ошибок.
5. Имена переменных корректные, отражают суть хранимых данных.
6. Создан текстовый интерфейс для всех программ.
7. Для всех задач обеспечен контроль ввода.
8. Использован оптимальный алгоритм поиска или сортировки.
9. Выполнены все четыре задания.

### Как отправить работу на проверку

В форме ниже прикрепите ссылки на ваши проекты в repl.it — по одной на каждое задание.

## Урок 5. Типы данных

## Урок 6. Указатели

### Цель домашнего задания

• Приобрести навыки работы с указателями на различные типы  
• Научиться работать с char\* как со строкой

### Задача 1

#### Что нужно сделать:

Написать функцию, принимающую два указателя на int и меняет местами содержимое данных указателей.  
Пример:

```
int a = 10;

int b = 20;

swap(&a, &b);

std::cout << a << “ “ << b;

// 20 10
```

[]()
**Чек-лист для проверки задачи:**  
• Функция принимает корректные типы данных, тип возвращаемого значения -- void  
• Функция не использует библиотек кроме \<iostream>  
• Функция меняет значения по указателям

#### Как отправить задание на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задача 2

#### Что нужно сделать:

Написать функцию, которая принимает указатель на тип int, по которому размещены 10 переменных типа int. Функция ничего не возвращает, но по тому же указателю элементы должны лежать в обратном порядке.

Чек-лист для проверки задачи:  
• Функция принимает корректные типы данных, тип возвращаемого значения -- void  
• Функция не использует библиотек кроме <iostream>  
• По переданному указателю лежат переменные в обратном порядке

#### Как отправить задание на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задача 3

#### Что нужно сделать:

Написать функцию, которая принимает указатель на char, по которому лежит строка.
Функция должна возвращать true, если вторая строка является подстрокой первой.

Пример:

```
const char* a = "Hello world";
const char* b = "wor";
const char* c = "banana";
std::cout << substr(a,b) << " " << substr(a,c);
// true false
```

**const-квалификатор**  
const является квалификатором типа, применяемым к переменным, значения которых нельзя изменять.  
Например, если в коде написать:  
const int a = 2;  
то впоследствии значение переменной невозможно изменить, а запись вида  
a = 3;  
приведёт к ошибке компилятора.

#### Чек-лист для проверки задачи:

• Функция принимает корректные типы данных, тип возвращаемого значения -- bool  
• Функция не использует библиотек кроме <iostream> и <cstring> или другую для работы со строками  
• Функция корректно определяет, является ли вторая строка подстрокой первой.

### Советы и рекомендации:

Ознакомьтесь с материалами для лучшего понимания темы:  
• [«Размещение объектов в оперативной памяти. Понятие указателя»](https://www.rsdn.org/article/cpp/ObjectsAndPointers.xml).  
• [«Разбираемся с управлением памятью в современных языках программирования»](https://habr.com/ru/articles/489360/).

### Как отправить задание на проверку

Прислать ссылку на repl.it или файл .срр с решением.

## Урок 7. Расширенная работа с функциями

### Цели домашнего задания:

• Приобрести навыки работы со ссылками на различные типы.  
• Закрепить знания об аргументах функции по умолчанию.  
• Закрепить знания о передаче параметров в функции по ссылке.  
• Овладеть рекурсией как алгоритмическим инструментом.

### Задача 1

#### Что нужно сделать:

Напишите функцию swapvec, принимающую std::vector<int> и указатель на массив переменных типа int (одного размера) и обменивающую значения этих массивов.

```
Пример:

std::vector<int> a = {1,2,3,4};
int b[] = {2,4,6,8};
swapvec(a,b);
for(int i = 0; i < 4; ++i)
std::cout << a[i];
std::cout << std::endl;
for(int i = 0; i < 4; ++i)
std::cout << b[i];

Вывод:
2468
1234
```

#### Чек-лист для проверки задачи:

• Функция принимает корректные типы данных, тип возвращаемого значения — void.  
• Функция не использует библиотек кроме <iostream> и <vector>.  
• Функция меняет значения между объектами.  
• Вектор передаётся по ссылке.

### Как отправить задание на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

### Задача 2

### Что нужно сделать:

Кролик сидит на нулевой ступеньке большой лестницы. Он может прыгать на одну или более ступенек вверх, но не далее чем на k. Кролик хочет допрыгать до n-й ступеньки, но может сделать это большим количеством способов.
Напишите рекурсивную функцию, которая принимает число n типа int и число k — максимальную длину прыжка, а возвращает количество способов, которым кролик может доскакать до n-й ступеньки. В функции для аргумента “максимальная длина прыжка” задать значение, по умолчанию равное 3.

```
Пример:
Ввод: 3, 2
Вывод: 3
Пояснение: (1,2), (2,1), (1,1,1)
```

#### Чек-лист для проверки задачи:

• Функция принимает корректные типы данных, тип возвращаемого значения — int.  
• Функция не использует библиотек кроме <iostream>.  
• Функция рекурсивная.  
• Функция содержит значение по умолчанию.

### Как отправить задание на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

### Задача 3

#### Что нужно сделать:

Напишите рекурсивную функцию, которая принимает большое число n типа long long и переменную ans, а возвращает void. После завершения работы функции в переменной ans должно оказаться количество чётных цифр в записи числа n.

```
Пример:

int ans;
evendigits(9 223 372 036 854 775 806, ans);
//ans == 10

Пояснение: 9 223 372 036 854 775 806
```

#### Чек-лист для проверки задачи:

• Функция принимает корректные типы данных, тип возвращаемого значения — void.  
• Функция не использует библиотек кроме <iostream>.  
• Функция рекурсивная.  
• Функция содержит параметр по ссылке.

### Как отправить задание на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

> Промежуточная аттестация обязательна к сдаче для допуска к итоговой аттестации и получения документа об обучении
