# Массивы и Указатели в C++
## Урок 1. Одномерные массивы. Базовые алгоритмы на массивах
### В практической работе есть:

Обязательные задачи помогут проверить, как вы усвоили материал модуля. Их нужно сдать на проверку куратору.
Дополнительные задачи подойдут тем, кто хочет ещё немного потренироваться, решая задачки по программированию. Вы также можете отправлять их на проверку и получать обратную связь куратора, хотя это необязательно.
Цели практической работы:

• Приобрести навыки работы с одномерными массивами различных типов.  
• Научиться работать с индексацией, в том числе проходом по циклу.  
• Найти и освоить некоторые алгоритмические подходы к работе с массивами.  
### Что входит в практическую работу

Обязательные задачи:
1. Многоквартирный дом.
2. Сортировка.
3. Использование assert.

Дополнительные задачи:  
4. Ряд чисел*.

### Задание 1. Многоквартирный дом

#### Что нужно сделать:
На вход программе поступают десять фамилий в формате строк. Это фамилии жильцов квартир с первой по десятую. Необходимо прочитать эти фамилии и записать в одномерный массив. Далее пользователь вводит три номера квартир. Необходимо вывести в консоль фамилию жильца, проживающего в этой квартире. Если пользователь введёт некорректный номер квартиры, необходимо сообщить ему об этом.

Пример:
```
← SidorovA
← IvanovA
← PetrovA
← SidorovB
← IvanovB
← PetrovB
← SidorovC
← IvanovC
← PetrovC
← SidorovD
←10
→SidorovD
←1
→SidorovA
←5
→IvanovB
```
#### Что оценивается:
• Используется массив строк для хранения данных.  
• В коде не используются библиотеки, кроме <iostream> и <string>.  
• Программа проверяет доступность элемента по индексу и выдаёт корректный результат.  

#### Задание 2. Сортировка

#### Что нужно сделать:
Пользователь вводит в консоль 15 дробных чисел. Необходимо прочитать их и вывести в консоль в порядке от большего к меньшему. По возможности используйте минимум дополнительной памяти и проходов по массиву.

Пример:
```
Ввод: 1.2 2.3 1.11 3.4 5.5 5.4 5.3 5.1 1.5 1.25 5.41 5.31 5.11 1.51 1.251
Вывод: 5.5 5.41 5.4 5.31 5.3 5.11 5.1 3.4 2.3 1.51 1.5 1.251 1.25 1.2 1.11
```
#### Рекомендации по выполнению
Воспользуйтесь дополнительными материалами.  
Об алгоритмах:  
• Описание алгоритмов сортировки и сравнение их производительности  
• Структуры данных: двоичная куча (binary heap)  
Подробнее о сложности и нотации большого O:  
• Оценка сложности алгоритмов, или Что такое О(log n)  
• Big O Notation: что это такое и как её посчитать  
• Big O. Оценка сложности алгоритмов  
Об алгоритмах сортировок, у которых сложность меньше O(n^2).  
HeapSort имеет сложность n*log(n):  
• Пирамидальная сортировка (HeapSort)  
• HeapSort  
MergeSort имеет сложность n*log(n):  
• Описание алгоритмов сортировки и сравнение их производительности  
• MergeSort  

#### Что оценивается:
• Используется массив чисел с плавающей точкой для хранения данных.  
• В коде не используются библиотеки, кроме <iostream>.  
• Программа корректно использует обращения по индексам и выдаёт правильный ответ.  
• Асимптотическая сложность алгоритма не более O(n^2).  
• Числа выводятся от большего к меньшему.  

### Задание 3. Использование assert

#### Что нужно сделать:
Создайте в своей программе функцию float travelTime(float distance, float speed). Она будет находить время в пути и при этом использовать assert, чтобы отбросить нулевую и отрицательную скорость. Вызовите эту функцию в main. Убедитесь, что падение происходит за счёт assert. Не забудьте подключить заголовочный файл cassert.

#### Что оценивается:
При запуске происходит падение с указанием исходника и строки в нём, на которой расположен вызов макроса assert.

#### Критерии оценки работы
• Программы запускаются и корректно работают, нет синтаксических ошибок.  
• Имена переменных корректные, отражают суть хранимых данных.  
• Создан текстовый интерфейс для всех программ.  
• Для всех заданий обеспечен контроль ввода, который обусловлен   логикой работы программы. Не должно быть обращения к элементам за границы контейнера хранения.  
• В решении программ соблюдается необходимая асимптотическая сложность.  

### Задание 4. Ряд чисел* (дополнительное задание)

#### Что нужно сделать:
В программе инициализирован массив из 15 целых положительных чисел. Эти числа являются множеством из 14 последовательных чисел, начиная с Х (Х может быть любым), а одно число из ряда повторяется. Необходимо найти повторяющееся число и вывести его в консоль. По возможности используйте минимум дополнительной памяти и проходов по массиву.

Пример:
```
int numbers[15] = {114, 111, 106, 107, 108, 105, 115, 108, 110, 109, 112, 113, 116, 117, 118}
В данном примере Х — это 105, а повторяющееся число — 108.
```
#### Рекомендации по выполнению
Это задание с подвохом. Подумайте, как его можно было бы легко решить за O(n). На всякий случай оставляем для вас подсказку. Рекомендуем воспользоваться при необходимости.

#### Что оценивается:
Используется массив int для хранения данных.  
В коде не используются библиотеки, кроме <iostream>.  
Программа корректно использует обращения по индексам и выдаёт правильный ответ.  
Асимптотическая сложность алгоритма менее O(n^2).  

### Как отправить работу на проверку

Пришлите для каждого задания ссылку на repl.it или файл .срр с решением через форму ниже.

## Урок 2. Знакомство с std::vector v2

### Практическая работа

### Цель практической работы:
• Научиться работать с типом std::vector.  
• Попробовать на практике использовать функции для работы с vector.  

### Задача 1

#### Что нужно сделать
Необходимо из заданного пользователем вектора удалить число X.

Как работает программа
1. Пользователь вводит с клавиатуры число n — размер вектора, который надо заполнять.
2. Пользователь вводит n целых чисел, которые заполняют вектор.
3. Пользователь вводит значение — X. X — удаляемое из вектора значение. Необходимо удалить из вектора все элементы, которые равны заданному значению.
4. В конце программы необходимо вывести итоговое состояние вектора.

Пример выполнения
```
Input vector size: 5
Input numbers: 1 3 3 5 1
Input number to delete: 3
Result: 1 5 1
```

Пояснение  
Пользователь ввёл 5, потом числа 1, 3, 3, 5, 1 и потом число 3. В векторе должны остаться числа 1, 5, 1, которые надо вывести на экран.

#### Что оценивается
• Не удалено лишних элементов.  
• Все элементы, которые необходимо удалить, удалены.  
• Для удаления элементов из вектора использована функция pop_back()  
• Удаления из вектора совершены in-place, т.е. при удалении из вектора не используются дополнительные структуры данных или переменные.  
• Решение использует только один вектор.  

### Задача 2

#### Что нужно сделать
С помощью списка инициализации задаётся вектор цен на продукты (дробными
числами). Таким же образом с помощью списка инициализации задаётся вектор покупок (в виде индексов), которые совершает человек. Необходимо вывести на экран итоговую стоимость покупок. Вектор цен и вектор покупок можно задать напрямую в коде.

Пример выполнения
```
// Вектор цен выглядит так: {2.5, 4.25, 3.0, 10.0}.
std::vector<float> prices {2.5, 4.25, 3.0, 10.0};
// Вектор покупок: {1, 1, 0, 3}, то есть два товара по индексу 1 и по одному — индексов 0 и 3.
std::vector<int> items {1, 1, 0, 3};

Суммарная стоимость будет равна 21.0.
```

#### Советы и рекомендации
При получении итоговой стоимости покупок не нужно делать циклы по обоим векторам, достаточно одного цикла.

#### Что оценивается
Программа не допускает выхода за границы вектора цен.

### Задача 3

#### Что нужно сделать
Вам дали задание разработать хранилище для целочисленных значений во встраиваемой операционной системе. Такие системы работают в большей части техники, которая нас окружает: автомобилях, стиральных машинах, микроволновках, холодильниках. Только вот незадача: объём памяти этой системы очень небольшой, поэтому в хранилище не может находиться более 20 элементов.
В хранилище, являющееся вектором, с клавиатуры приходят целочисленные значения и помещаются один за другим.
При вводе «−1» с клавиатуры необходимо вывести всё содержимое хранилища (20 или менее элементов). При выводе элементы должны быть в том порядке, в котором они добавлялись.
Попробуйте написать максимально оптимизированное решение этой задачи, чтобы совершалось как можно меньше расширений и перемещений элементов внутри вектора.
Чтобы задать размера вектора равным 20, используйте:
```
std::vector<int> db(20);
// ^ Задаём размер вектора при создании
```
Пример выполнения:
```
input number: 1
input number: 2
input number: 3
…
input number: 19
input number: 20
input number: -1
output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
input number: 21
input number: 22
input number: 23
input number: -1
output: 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
```

#### Рекомендации по выполнению
Посмотрите, как работает кольцевой буфер. Этот алгоритм поможет быстрее найти решение.

#### Что оценивается
• Размер вектора не превышает 20 элементов.  
• Нет изменений в размере вектора (это выполняется, если вы выбрали верный алгоритм решения).  

### Критерии оценки
• Выполнены все три задания.  
• Программы запускаются и корректно работают, нет синтаксических ошибок.  
• Имена переменных корректные, отражают суть хранимых данных.  
• Создан текстовый интерфейс для всех программ.  
• Для всех задач обеспечен контроль ввода.  
• В циклах нет выхода за границы векторов.  

### Как отправить работу на проверку

В форме ниже прикрепите ссылки на ваши проекты в repl.it, по одной на каждое задание.


