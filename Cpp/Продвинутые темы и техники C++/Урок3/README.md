## Урок 3. Структуры данных

В практической работе есть обязательные задачи и дополнительное задание.
Обязательные задачи помогут понять, как вы усвоили материал модуля. Их нужно сдать на проверку куратору.
Дополнительное задание подойдёт тем, кто хочет ещё немного потренироваться, решая задачки по программированию. Вы также можете отправить его на проверку и получать обратную связь куратора.

### Цели практической работы

Вы потренируетесь работать со структурами данных:  
• объявлять и инициализировать структуры;  
• считывать и записывать их поля;  
• заводить массивы.

### Что входит в практическую работу

1. Ведомость учёта.
2. Модель данных для посёлка.
3. Математический вектор.
4. Пошаговая ролевая игра (дополнительное задание).

Разработку нужно выполнить в среде [VS Code](https://code.visualstudio.com/download). Текстовые документы можно редактировать в стандартном блокноте.

### 1. Ведомость учёта

#### Что нужно сделать

Вы уже создавали программу чтения и записи ведомости. Теперь её нужно обобщить и дополнить использованием структур.  
Формат ведомости прежний:  
• сначала — имя и фамилия получателя денег,  
• далее — дата выдачи в формате ДД.ММ.ГГГГ,  
• затем — сумма выплаты в рублях.  
Данные разделяются пробелами. В конце каждой записи должен быть перевод строки. Структура данных должна соответствовать этому формату.

При старте программы пользователь отправляет команду: list или add. Команда list осуществляет чтение из файла ведомости, как и прежде, только уже в структуры данных, и отображает их на экране.  
Команда add добавляет новую запись в конец ведомости.

#### Советы и рекомендации

• Чтобы определить, где заканчивается файл, используйте функцию file.eof().  
• Из-за завершающего переноса строки при чтении данных из файла стоит отдельно прочитать имя получателя денег. Если после чтения имени получателя денег признак file.eof() принял значение true, значит, файл закончился.  
• Используйте вектор структур. Для выбора команды потребуется подобная конструкция:

```
if (command == "list")
{
…
}
```

### 2. Модель данных для посёлка

#### Что нужно сделать

Используя структуры данных, создайте подробную модель посёлка.  
Что известно  
• Посёлок состоит из участков, и у каждого участка есть свой номер.  
• На любом участке может стоять жилой дом, а также могут быть и другие сооружения:  
— гараж,  
— сарай (бытовка),  
— баня.  
• У каждого здания есть информация о площади, которую оно занимает на участке.  
• В доме может быть 1–3 этажа, на этаже — 2–4 комнаты:  
— спальня,  
— кухня,  
— ванная,  
— детская,  
— гостиная.  
• У каждого этажа есть информация о количестве комнат и высоте потолка на этаже.  
• У каждой комнаты есть информация о занимаемой площади.  
• В доме и бане может быть печь с трубой.  
Для всех упомянутых сущностей нужно объявить структуры данных.

#### Обязательно для выполнения задания

Опишите структуры данных для создания модели посёлка. Структуры должны быть:  
• связными и легко расширяемыми,  
• без дублирующих конструкций.

#### Дополнительно

Реализуйте заполнение структур данных.  
Пользователь заполняет данные о посёлке: вводит общее количество участков, а потом детализирует каждый.  
Сначала указывается количество построек на участке, а затем — информация, какие это постройки, сколько этажей в доме, какие комнаты на этажах.  
После ввода данных можно рассчитать суммарный параметр, например процент земли, занимаемой постройками, от общей площади посёлка. Главное в этой задаче не операция подсчёта, а структуры данных.

#### Советы и рекомендации

• Используйте свои знания о типах данных в C++.  
• Можно применять перечисления и векторы, создавать структуры внутри структур и так далее.  
• Перечислять комнаты и типы зданий нужно следующим образом:

```
enum room_type
{
living,
children,
…
```

• Затем нужно использовать полученный тип внутри структуры. Алгоритм заполнения каждого объекта одинаковый:  
— создать объект нужного типа,  
— ввести с клавиатуры значения,  
— добавить объект в вектор при помощи push_back.

### 3. Математический вектор

#### Что нужно сделать

Реализуйте структуру двумерного математического вектора и основные операции над ним. Обе координаты вектора (x и y) должны быть вещественными числами.  
Начиная работу с программой, пользователь вводит команду. Затем в зависимости от команды пользователь вводит аргументы. Это могут быть как векторы, так и обычные скалярные значения. Результат помещается в стандартный вывод. Это тоже может быть или вектор, или скаляр.

Реализуйте в виде отдельных функций операции:  
• сложение двух векторов — команда add;  
• вычитание двух векторов — команда subtract;  
• умножение вектора на скаляр — команда scale;  
• нахождение длины вектора — команда length;  
• нормализация вектора — команда normalize.

#### Советы и рекомендации

Для выбора команды используйте конструкцию вида if (operation == "add"). Тут так и напрашиваются отдельные функции для каждой операции.

### 4. Пошаговая ролевая игра (дополнительное задание)

#### Что нужно сделать

Реализуйте упрощённую версию пошаговой ролевой игры.  
Действие разворачивается на карте размером 20 на 20 клеток. По клеткам перемещаются игрок и его противники.  
После каждого хода игрока карта показывается вновь со всеми противниками на ней:  
• игрок помечается буквой P,  
• противники — буквой E,  
• пустые места — точкой.  
Каждый персонаж игры представлен в виде структуры с полями:  
• «Имя»,  
• «Жизни»,  
• «Броня»,  
• «Урон».  
Сначала создаётся пять противников в случайных клетках карты:  
• Имена противникам задаются в формате Enemy #N, где N — порядковый номер.  
• Уровень жизни противников задаётся случайно — от 50 до 150.  
• Уровень брони варьируется от 0 до 50.  
• Урон тоже выбирается случайно — от 15 до 30 единиц.  
Игрок конструирует своего персонажа самостоятельно. Задаёт все его параметры, включая имя. Все персонажи появляются в случайных местах карты.  
Игрок ходит с помощью команд: L, R, U, D (по первым буквам слов left, right, up, down). В зависимости от команды выбирается направление перемещения: влево, вправо, вверх, вниз.  
Противники перемещаются в случайном направлении.  
Если игрок перемещается в сторону, где уже кто-то находится, он наносит этому персонажу урон. Противники при этом никогда не бьют друг друга: они просто пропускают ход и остаются на своём месте. За пределы карты (20 на 20 клеток) ходить нельзя никому. Если кто-то выбрал направление за границами, ход пропускается.
Формула расчёта урона совпадает с той, что была в материале. Жизни уменьшаются на размер урона. При этом броня тоже сокращается на приведённый урон.
Игра заканчивается тогда, когда умирают либо все противники, либо игрок. В первом случае на экран выводится сообщение о победе, во втором — о поражении.
Если в начале хода игрок вводит команду save или load вместо направления перемещения, то игра либо сохраняет своё состояние в файл, либо загружает это состояние из файла.

#### Советы и рекомендации

• Для определения команды персонажа можно внутри структуры данных о нём завести флаг.  
• Для отображения координат персонажей можно использовать структуру вектора из другой задачи, но заменить типы координат.  
• Для сохранения параметров игры и их загрузки можно работать с текстовыми данными. Однако записать всё в двоичном формате проще, главное — соблюдать последовательность полей:

```
std::ofstream file("save.bin", std::ios::binary);
for (int i = 0; i < 6; ++i) {
file.write((char\*)&(characters[i].position),
sizeof(characters[i].position));
…
```

• При загрузке используйте ifstream и ту же последовательность полей.

Задание необязательно сдавать на проверку. Но если хотите это сделать, куратор будет учитывать следующее:  
• Корректно работает сохранение и загрузка в игре.  
• После загрузки все атрибуты игрока, включая имя, восстанавливаются из файла.  
• После загрузки количество противников на поле соответствует количеству противников при сохранении.  
• Все игроки после загрузки появляются в местах, где они находились при сохранении.  
• При ходе игрока не появляются новые противники.  
• Перед загрузкой файла сохранения проверяется, есть ли он в операционной системе.

#### Что оценивается

• Программы запускаются и корректно работают, нет синтаксических ошибок.  
• Имена переменных корректные, отражают суть хранимых данных.  
• Создан текстовый интерфейс для всех программ.  
• Во всех задачах корректно использованы структуры.  
• Перед загрузкой файла в задачах проверяется его существование на диске.  
• Выполнено минимум три задания.

#### Как отправить работу на проверку

Пришлите ссылку на Repl.it или файлы CPP (для каждого задания нужен отдельный) с решением через форму ниже.
