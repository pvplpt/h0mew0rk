# Продвинутые темы и техники C++

## Урок 1. Чтение из файлов

### Цели практической работы

Приобрести практическое понимание работы с файлами.

#### Научиться:

• открывать файлы по указанному пути,  
• считывать разные типы данных из текстовых файлов,  
• считывать данные из бинарных файлов,  
• составить простейшие текстовые данные в редакторе,  
• считывать массивы данных.

### Что входит в практическую работу

1. Разработать программу поиска слов в файле.
2. Разработать простейший просмотрщик текстовых файлов.
3. Реализовать программу чтения и анализа ведомости с выплатами.
4. Разработать детектор PNG-файла.
5. Реализовать версию игры «Что? Где? Когда?».

### Общие условия

Разработка выполняется в среде VS Code. Текстовые документы можно редактировать в стандартном блокноте.

### Задание 1. Разработка программы поиска слов в файле

#### Что нужно сделать

Составьте небольшой текстовый файл «words.txt», в котором последовательно, через пробелы и переносы строк расположены различные слова. Можете использовать любые англоязычные слова. Разработайте программу, которая искала бы среди этих слов нужное пользователю и выводила бы общее количество повторений этого слова. 0 — если слово вообще не присутствует в файле.

#### Что оценивается

Корректность работы программы на созданных вами вводных данных. Число найденных слов должно соответствовать.

#### Как отправить работу на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 2. Разработка просмотрщика текстовых файлов

#### Что нужно сделать

Разработайте простейший просмотрщик текстовых файлов. В начале программы пользователь вводит путь к текстовому файлу, который требуется открыть и просмотреть. Внутренности файла необходимо вывести в стандартный вывод. Программа должна работать для любых текстовых файлов в формате TXT, но вы можете создать и свой отдельный файл для теста. Главное, чтобы файл был англоязычным, дабы избежать проблем с кодировками.

#### Советы и рекомендации

• Для проверки того, был ли на самом деле открыт файл, используйте метод is_open. Он вернёт true, если файл был благополучно открыт, и false, если что-то пошло не так, к примеру, если путь к файлу невалидный.  
• Файл надо считывать постепенно, отдельными фрагментами, ведь он может быть весьма большим. Для этого лучше всего пользоваться методом gcount, так как он ещё вернёт количество байт, которые были считаны по факту методом read. Сами эти фрагменты могут храниться в специальном буфере, как и в примере из лекций, но его размер и второй аргумент к функции read надо рассчитать так, чтобы выводились все символы, без обрезки последней буквы.  
• Файл можно открыть в бинарном формате.

#### Что оценивается

Показ файла на экране должен соответствовать тому, что мы наблюдаем в стандартном блокноте.

#### Как отправить работу на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 3. Реализация программы чтения ведомости

#### Что нужно сделать

Реализуйте программу чтения информации из ведомости по учёту выплат. Сама ведомость представляет собой следующую таблицу:  
• имя и фамилия человека;  
• количество денег, которые были выплачены лицу;  
• дата выплаты в формате ДД.ММ.ГГГГ.

На основе данных из ведомости следует подсчитать общее количество выплаченных средств и определить человека с максимальной суммой выплат.  
Пример данных ведомости

```
Tom Hanks 35500 10.11.2020
Rebecca Williams 85000 1.1.2021
Sally Field 15600 15.8.2021
Michael Humphreys 29400 23.5.2020
Harold Herthum 74300 9.6.2019
George Kelly 45000 12.3.2018
Bob Penny 12500 13.5.2020
John Randall 23400 2.10.2020
Sam Anderson 6500 15.7.2020
Margo Moorer 12350 24.2.2019ш
```

#### Что оценивается

Корректное отображение общей суммы выплат и самого крупного получателя денежных средств.

#### Как отправить работу на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 4. Разработка детектора PNG-файла

#### Что нужно сделать

Разработайте программу, которая получает на вход, в стандартный ввод, путь к файлу. На выходе программа должна определить, является ли данный файл PNG-изображением. Данная процедура не просто должна смотреть на расширение файла, но и произвести минимальный анализ его внутренностей, в бинарном режиме.
Внутренности валидного бинарного файла начинаются со специального 8-байтового заголовка. Нас будут интересовать первые четыре байта. Первый байт всегда имеет значение −119 (число со знаком минус), а следующие — это просто символы ‘P’, ‘N’, ‘G’, расположенные друг за другом. Обратите внимание, что все они в верхнем регистре.
По результатам проверки пути и внутренностей требуется сообщить пользователю о результате проверки в стандартный вывод.

#### Советы и рекомендации

Чтобы определить расширение файла, используйте функцию substr, которая получает офсет и длину подстроки и возвращает её.

#### Что оценивается

Для произвольных путей файлов, введённых пользователем, требуется выдавать корректный результат — являются ли они PNG-файлами или нет.

#### Как отправить работу на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 5. Реализация игры «Что? Где? Когда?»

#### Что нужно сделать

Реализуйте простую версию интеллектуальной игры «Что? Где? Когда?».  
Как происходит игра  
В начале каждого хода игроки вращают волчок, то есть выбирают сектор на столе, который сейчас играет. Всего таких секторов 13. Сектор выбирается так: с клавиатуры вводится офсет (смещение) относительно текущего сектора на барабане. Исходя из этого офсета вычисляется новый активный сектор, который и будет играть в этом ходе. Если выпавший сектор уже играл, выбирает следующий не игравший за ним. В начале всей игры стрелка установлена на первом секторе.

Как только играет какой-то из секторов, с него берётся письмо с вопросом — то есть считывается из файла данного сектора. Вопрос показывается на экране.  
После того как вопрос показан, от игрока ожидается ответ на него. Игрок вводит этот ответ с помощью стандартного ввода. То, что он ввёл, сравнивается с ответом, который хранится во втором файле, ассоциированном с активным сектором. Данный файл должен содержать лишь одно слово-ответ.

Если ответ знатока-игрока был правильным, ему начисляется один балл. Если неверен, то балл уходит телезрителям.  
Игра продолжается до тех пор, пока или игрок, или зрители не наберут шесть баллов. После этого называется победитель и программа заканчивает работу.

#### Что оценивается

Игра должна корректно работать от первого хода до последнего. В результате обязательно должен выявляться победитель.

#### Как отправить работу на проверку

Прислать ссылку на repl.it или файл .срр с решением.

## Урок 2. Запись в файлы

### Цели домашнего задания

Приобрести практическое понимание работы с файлами.

#### Научиться:

• открывать файлы на запись по указанному пути и закрывать их;  
• записывать разные типы данных в файлы;  
• записывать массивы данных в файлы;  
• пользоваться генератором случайных чисел.

### Что входит в домашнее задание

1. Реализовать запись в ведомость учёта.
2. Реализовать рисование случайных картин.
3. Реализовать симуляцию игры «Рыбалка».
4. Реализовать симуляцию работы банкомата.

### Общие условия

Разработка выполняется в среде [CLion](https://www.jetbrains.com/clion). Текстовые документы можно редактировать в стандартном блокноте.

### Задание 1. Реализация записи в ведомость учёта

#### Что нужно сделать

В одном из прошлых заданий мы уже создавали программу чтения и анализа ведомости выплат. Теперь требуется создать простую программу записи в эту ведомость.
Формат ведомости прежний. Сначала идёт имя и фамилия получателя денежных средств, далее располагается дата выдачи в формате ДД.ММ.ГГГГ. Завершает запись сумма выплаты в рублях. Данные разделяются между собой пробелами. В конце каждой записи должен быть расположен перевод строки.  
При старте программы пользователь последовательно вводит данные для новой записи, которые записываются затем в файл в текстовом режиме. Программа должна добавлять новые записи в конец файла, не удаляя его текущее содержимое.

#### Советы и рекомендации

Введённые данные рекомендуется хотя бы минимально валидировать перед их записью.
Для валидации даты в указанном формате можно использовать функции std::stoi и std::subtr с корректно указанным диапазоном символов в дате. К примеру, вызов std::stoi(date.substr(3, 2)) вычленит из строковой даты целочисленный месяц для последующего анализа.

#### Что оценивается

Корректность работы программы. Программа должна дозаписывать данные в конец существующего списка.

#### Как отправить задание на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 2. Реализация рисования случайных картин

### Что нужно сделать

С помощью генератора случайных чисел рисуется картинка из нулей и единиц. На вход от пользователя принимается размер картины: высота и ширина в пикселях. На выходе нужно создать файл pic.txt, содержимое которого будет наполнено случайными нулями и единицами в рамках размера картины.  
Это ещё не всё. Если вы запустите программу несколько раз на одних и тех же исходных данных (ширина и высота картины), вы очень скоро обнаружите, что всё время выводится одна и та же картинка. Дело в том, что у генератора случайных чисел есть ещё и «зерно», от которого он отталкивается. Если это зерно не меняется, то и серия из rand() всегда будет возвращать одни и те же случайные числа.  
Чтобы разнообразить вывод, вы можете использовать вызов std::srand(std::time(nullptr)); в самом начале программы. Эта операция задаёт начальное зерно случайных чисел в зависимости от текущего времени. Для её корректной работы не забудьте также включить заголовочный файл <ctime>.

#### Что оценивается

Корректность работы программы по созданию случайных изображений заданного размера.

#### Как отправить задание на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 3. Реализация симуляции игры «Рыбалка»

#### Что нужно сделать

Реализуйте простую симуляцию игры в рыбалку. В исходном текстовом файле реки (river.txt) задаётся список из видов рыб, которые можно в ней поймать. Рыбок может быть сколько угодно, разных видов. Виды при этом могут повторяться.  
В начале программы пользователь указывает, какую именно рыбу он сейчас будет ловить — вид этой рыбы. После этого из первого файла друг за другом осуществляется чтение его содержимого, вид за видом. Если на отдельных шагах вид совпал с указанным пользователем, в выходной файл basket.txt (корзинка) записывается этот вид.  
В конце программы показывается, сколько было поймано рыб за текущую ловлю. Программу можно запускать несколько раз, при этом уже пойманные рыбы должны сохраняться в файле-корзинке.  
Пример содержания исходного файла

```
sunfish
shad
carp
bass
bullhead
carp
walleye
catfish
carp
```

#### Что оценивается

Корректность работы программы симуляции игры в рыбалку. Пойманные рыбы должны записываться в выходной файл.

#### Как отправить задание на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 4. Реализация симуляции банкомата

#### Что нужно сделать

Требуется реализовать упрощённую симуляцию работы банкомата. В банкомате могут храниться только бумажные купюры номиналом от 100 до 5000 рублей. Максимально в банкомате может храниться только 1000 купюр. Все они записываются в отдельный файл. У банкомата, как у устройства, две основных операции — снятие денег пользователем и наполнение деньгами инкассаторами банка.

Наполнение банкомата происходит, если при старте программы в консоль вводится символ плюс “+”. Количество купюр рассчитывается так, чтобы банкомат был заполнен полностью. Все купюры при этом выбираются случайным образом.  
Если на старте программы в консоль вводится минус (“-”), то симулируется снятие пользователем денег. Пользователь указывает сумму с точностью до 100 рублей. Мы будем считать, что каждый клиент обладает неограниченным балансом в системе и теоретически может снять любую сумму. На практике, если данная сумма не может быть снята из-за отсутствия подходящих денег в машине, показывается сообщение, что эта операция невозможна.  
После выполнения любой из операций программа завершает выполнение. Состояние банкомата должно храниться в отдельном бинарном файле, автономно.

#### Советы и рекомендации

Вы можете хранить массив купюр целиком, помечая отсутствующие позиции нулями.

#### Что оценивается

Корректность работы программы симуляции банкомата. Инкассация и снятие денег должны работать корректно.

#### Как отправить задание на проверку

Прислать ссылку на repl.it или файл .срр с решением.

## Урок 3. Структуры данных

В практической работе есть обязательные задачи и дополнительное задание.
Обязательные задачи помогут понять, как вы усвоили материал модуля. Их нужно сдать на проверку куратору.
Дополнительное задание подойдёт тем, кто хочет ещё немного потренироваться, решая задачки по программированию. Вы также можете отправить его на проверку и получать обратную связь куратора.

### Цели практической работы

Вы потренируетесь работать со структурами данных:  
• объявлять и инициализировать структуры;  
• считывать и записывать их поля;  
• заводить массивы.

### Что входит в практическую работу

1. Ведомость учёта.
2. Модель данных для посёлка.
3. Математический вектор.
4. Пошаговая ролевая игра (дополнительное задание).

Разработку нужно выполнить в среде [VS Code](https://code.visualstudio.com/download). Текстовые документы можно редактировать в стандартном блокноте.

### 1. Ведомость учёта

#### Что нужно сделать

Вы уже создавали программу чтения и записи ведомости. Теперь её нужно обобщить и дополнить использованием структур.  
Формат ведомости прежний:  
• сначала — имя и фамилия получателя денег,  
• далее — дата выдачи в формате ДД.ММ.ГГГГ,  
• затем — сумма выплаты в рублях.  
Данные разделяются пробелами. В конце каждой записи должен быть перевод строки. Структура данных должна соответствовать этому формату.

При старте программы пользователь отправляет команду: list или add. Команда list осуществляет чтение из файла ведомости, как и прежде, только уже в структуры данных, и отображает их на экране.  
Команда add добавляет новую запись в конец ведомости.

#### Советы и рекомендации

• Чтобы определить, где заканчивается файл, используйте функцию file.eof().  
• Из-за завершающего переноса строки при чтении данных из файла стоит отдельно прочитать имя получателя денег. Если после чтения имени получателя денег признак file.eof() принял значение true, значит, файл закончился.  
• Используйте вектор структур. Для выбора команды потребуется подобная конструкция:

```
if (command == "list")
{
…
}
```

### 2. Модель данных для посёлка

#### Что нужно сделать

Используя структуры данных, создайте подробную модель посёлка.  
Что известно  
• Посёлок состоит из участков, и у каждого участка есть свой номер.  
• На любом участке может стоять жилой дом, а также могут быть и другие сооружения:  
— гараж,  
— сарай (бытовка),  
— баня.  
• У каждого здания есть информация о площади, которую оно занимает на участке.  
• В доме может быть 1–3 этажа, на этаже — 2–4 комнаты:  
— спальня,  
— кухня,  
— ванная,  
— детская,  
— гостиная.  
• У каждого этажа есть информация о количестве комнат и высоте потолка на этаже.  
• У каждой комнаты есть информация о занимаемой площади.  
• В доме и бане может быть печь с трубой.  
Для всех упомянутых сущностей нужно объявить структуры данных.

#### Обязательно для выполнения задания

Опишите структуры данных для создания модели посёлка. Структуры должны быть:  
• связными и легко расширяемыми,  
• без дублирующих конструкций.

#### Дополнительно

Реализуйте заполнение структур данных.  
Пользователь заполняет данные о посёлке: вводит общее количество участков, а потом детализирует каждый.  
Сначала указывается количество построек на участке, а затем — информация, какие это постройки, сколько этажей в доме, какие комнаты на этажах.  
После ввода данных можно рассчитать суммарный параметр, например процент земли, занимаемой постройками, от общей площади посёлка. Главное в этой задаче не операция подсчёта, а структуры данных.

#### Советы и рекомендации

• Используйте свои знания о типах данных в C++.  
• Можно применять перечисления и векторы, создавать структуры внутри структур и так далее.  
• Перечислять комнаты и типы зданий нужно следующим образом:

```
enum room_type
{
living,
children,
…
```

• Затем нужно использовать полученный тип внутри структуры. Алгоритм заполнения каждого объекта одинаковый:  
— создать объект нужного типа,  
— ввести с клавиатуры значения,  
— добавить объект в вектор при помощи push_back.

### 3. Математический вектор

#### Что нужно сделать

Реализуйте структуру двумерного математического вектора и основные операции над ним. Обе координаты вектора (x и y) должны быть вещественными числами.  
Начиная работу с программой, пользователь вводит команду. Затем в зависимости от команды пользователь вводит аргументы. Это могут быть как векторы, так и обычные скалярные значения. Результат помещается в стандартный вывод. Это тоже может быть или вектор, или скаляр.

Реализуйте в виде отдельных функций операции:  
• сложение двух векторов — команда add;  
• вычитание двух векторов — команда subtract;  
• умножение вектора на скаляр — команда scale;  
• нахождение длины вектора — команда length;  
• нормализация вектора — команда normalize.

#### Советы и рекомендации

Для выбора команды используйте конструкцию вида if (operation == "add"). Тут так и напрашиваются отдельные функции для каждой операции.

### 4. Пошаговая ролевая игра (дополнительное задание)

#### Что нужно сделать

Реализуйте упрощённую версию пошаговой ролевой игры.  
Действие разворачивается на карте размером 20 на 20 клеток. По клеткам перемещаются игрок и его противники.  
После каждого хода игрока карта показывается вновь со всеми противниками на ней:  
• игрок помечается буквой P,  
• противники — буквой E,  
• пустые места — точкой.  
Каждый персонаж игры представлен в виде структуры с полями:  
• «Имя»,  
• «Жизни»,  
• «Броня»,  
• «Урон».  
Сначала создаётся пять противников в случайных клетках карты:  
• Имена противникам задаются в формате Enemy #N, где N — порядковый номер.  
• Уровень жизни противников задаётся случайно — от 50 до 150.  
• Уровень брони варьируется от 0 до 50.  
• Урон тоже выбирается случайно — от 15 до 30 единиц.  
Игрок конструирует своего персонажа самостоятельно. Задаёт все его параметры, включая имя. Все персонажи появляются в случайных местах карты.  
Игрок ходит с помощью команд: L, R, U, D (по первым буквам слов left, right, up, down). В зависимости от команды выбирается направление перемещения: влево, вправо, вверх, вниз.  
Противники перемещаются в случайном направлении.  
Если игрок перемещается в сторону, где уже кто-то находится, он наносит этому персонажу урон. Противники при этом никогда не бьют друг друга: они просто пропускают ход и остаются на своём месте. За пределы карты (20 на 20 клеток) ходить нельзя никому. Если кто-то выбрал направление за границами, ход пропускается.
Формула расчёта урона совпадает с той, что была в материале. Жизни уменьшаются на размер урона. При этом броня тоже сокращается на приведённый урон.
Игра заканчивается тогда, когда умирают либо все противники, либо игрок. В первом случае на экран выводится сообщение о победе, во втором — о поражении.
Если в начале хода игрок вводит команду save или load вместо направления перемещения, то игра либо сохраняет своё состояние в файл, либо загружает это состояние из файла.

#### Советы и рекомендации

• Для определения команды персонажа можно внутри структуры данных о нём завести флаг.  
• Для отображения координат персонажей можно использовать структуру вектора из другой задачи, но заменить типы координат.  
• Для сохранения параметров игры и их загрузки можно работать с текстовыми данными. Однако записать всё в двоичном формате проще, главное — соблюдать последовательность полей:

```
std::ofstream file("save.bin", std::ios::binary);
for (int i = 0; i < 6; ++i) {
file.write((char\*)&(characters[i].position),
sizeof(characters[i].position));
…
```

• При загрузке используйте ifstream и ту же последовательность полей.

Задание необязательно сдавать на проверку. Но если хотите это сделать, куратор будет учитывать следующее:  
• Корректно работает сохранение и загрузка в игре.  
• После загрузки все атрибуты игрока, включая имя, восстанавливаются из файла.  
• После загрузки количество противников на поле соответствует количеству противников при сохранении.  
• Все игроки после загрузки появляются в местах, где они находились при сохранении.  
• При ходе игрока не появляются новые противники.  
• Перед загрузкой файла сохранения проверяется, есть ли он в операционной системе.

#### Что оценивается

• Программы запускаются и корректно работают, нет синтаксических ошибок.  
• Имена переменных корректные, отражают суть хранимых данных.  
• Создан текстовый интерфейс для всех программ.  
• Во всех задачах корректно использованы структуры.  
• Перед загрузкой файла в задачах проверяется его существование на диске.  
• Выполнено минимум три задания.

#### Как отправить работу на проверку

Пришлите ссылку на Repl.it или файлы CPP (для каждого задания нужен отдельный) с решением через форму ниже.

## Урок 4. Словари std::map

### Цели домашнего задания

• Приобрести навыки работы с std::map.  
• Научиться вставлять, удалять и искать элементы.  
• Научиться использовать итераторы для прямого прохода по контейнеру.

### Что входит в задание

1. Написать программу «Телефонный справочник».
2. Написать программу «Регистратура».
3. Написать функцию, которая выводит анаграмму.

### Задание 1. Телефонный справочник

#### Что нужно сделать

Напишите программу «Телефонный справочник».  
На вход программе поступают запросы трёх типов:  
69-70-30 Ivanov — добавить телефон и фамилию абонента в справочник  
69-70-30 — узнать фамилию абонента по номеру телефона  
Ivanov — узнать телефон абонента по фамилии  
Необходимо выводить в консоль ответ на запросы 2 и 3. Обратите внимание, что абоненты по разным номерам могут иметь одинаковые фамилии. В таком случае на запрос 3 необходимо выдать все номера через пробелы.  
Операции запросов должны работать за O(logn) или O(logn × количество номеров с этой фамилией).

#### Чек-лист для проверки задачи

• Программа корректно выводит фамилии и списки номеров.  
• Программа использует только заголовочные файлы <iostream>, <string>, <map> и, возможно, вектор.

#### Как отправить задание на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

### Задание 2. Регистратура

#### Что нужно сделать

Напишите программу «Регистратура».  
На вход программе приходят строки с фамилиями или строка Next. Пришедшие люди становятся в очередь, а по запросу Next необходимо вызвать в регистратуру человека с фамилией, идущей первой в лексикографическом порядке (по алфавиту), и вывести его фамилию на экран. Фамилии пациентов могут повторяться.  
Каждый запрос (на добавление и вывод) должен работать за O(logn).

Пример:

```
← Sidorov
← Ivanov
← Ivanov
← Petrov
← Next
→ Ivanov
← Next
→ Ivanov
← Next
→ Petrov
```

#### Чек-лист для проверки задачи

• Программа корректно выводит фамилии в лексикографическом порядке.  
• Программа использует только заголовочные файлы <iostream>, <string>, <map>.

#### Как отправить задание на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

### Задание 3. Анаграммы

#### Что нужно сделать

Напишите функцию, которая принимает две строки и возвращает true, если первая строка является анаграммой второй (то есть можно получить первую строку из второй путём перестановки букв местами), и false иначе. Для достижения хорошей асимптотики решения рекомендуется использовать std::map.  
Пример анаграммы: лекарство — стекловар

#### Чек-лист для проверки задачи

• Функция принимает корректные типы данных, тип возвращаемого значения — bool.  
• Функция не использует библиотек, кроме <iostream>, <map>, <string>.  
• Функция корректно определяет, являются ли строки анаграммами.

#### Как отправить задание на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

## Урок 5. Макросы и препроцессор

### В практической работе есть:

Обязательные задачи помогут проверить, как вы усвоили материал модуля. Их нужно сдать на проверку куратору.  
Дополнительные задачи подойдут тем, кто хочет ещё немного потренироваться, решая задачки по программированию. Вы также можете отправлять их на проверку и получать обратную связь куратора, хотя это необязательно.

### Цели практической работы

• Познакомиться с работой препроцессора и попрактиковаться в работе с макросами.  
• Научиться:  
— объявлять и использовать макросы-константы,  
— объявлять и использовать макросы-функции,  
— пользоваться директивой препроцессора с условием,  
— смотреть итоговой исходный код после препроцессора.

### Что входит в практическую работу

Обязательные задачи:

1. Реализовать продвинутый ввод и вывод дней недели.
2. Реализовать вывод выбранного времени года.
   Дополнительные задачи:
3. Реализовать анализ вагонов.

### Общие условия

Разработка выполняется в среде VS Code.

### Задание 1. Реализация продвинутого ввода и вывода дней недели

#### Что нужно сделать

Используя макросы, реализуйте небольшую программу по вводу дня недели и выводу этого дня недели в текстовом виде в консоль.
В начале программы пользователь вводит день недели в виде его порядкового номера. В результате в консоли появляется буквенное отображение этого дня недели.
В этом упражнении запрещается использовать классические переменные, кроме как для хранения ввода пользователя. Использовать строковые литералы напрямую тоже нельзя. Всё должно быть реализовано исключительно на макросах.

#### Советы и рекомендации

Конкатенация двух фрагментов может породить токен, который в свою очередь является именем макроса, и этот макрос тоже раскроется. Используйте это свойство для перевода константы дня недели в строковый литерал.  
Обязательно просмотрите итоговый код после препроцессинга из CLion с помощью Shift-Shift → Preprocess current TU.

#### Что оценивается

Корректность работы программы. Модульность и элегантность решения с помощью макросов.

#### Как отправить работу на проверку

Пришлите ссылку на repl.it или файл CPP с решением через форму ниже.

### Задание 2. Вывод времени года

#### Что нужно сделать

Используя макросы вместе с условными директивами прекомпиляции (#if / #endif), реализуйте простую программу по выводу названия времени года в консоль.
Пользователь программы, который будет иметь дело с вашим кодом, в этом случае тоже программист. С помощью определения одного из макросов (в самом коде): SPRING, SUMMER, AUTUMN или WINTER он задаёт сезон, название, которое хочет увидеть на экране. При компиляции и запуске программы на экране должно появиться название именно этого сезона и только его.

#### Советы и рекомендации

Так как препроцессор работает до компиляции, то в #if/#endif-директивы вы можете обернуть всю функцию main сразу.  
Обязательно просмотрите итоговый код после препроцессинга из CLion с помощью Shift-Shift → Preprocess current TU.

#### Что оценивается

Корректность работы программы при разных заданных дефинициях макросов.

#### Как отправить работу на проверку

Пришлите ссылку на repl.it или файл CPP с решением через форму для сдачи домашнего задания.

### Задание 3. Анализ заполненности вагонов в поезде\* (дополнительное задание)

#### Что нужно сделать

В поезде всего 10 вагонов. В каждом из этих вагонов может находиться до 20 пассажиров — это их оптимальное количество. Проанализируйте количество людей в каждом вагоне и сначала сообщите об излишне заполненных вагонах, далее о вагонах с пустыми пассажирскими местами. В заключение выведите общее количество пассажиров во всех вагонах.  
При старте программы пользователь вводит количество пассажиров в каждом вагоне. Замечания о вагонах должны выводиться в стандартную консоль.
При выполнении задания пользоваться нельзя напрямую пользоваться for-циклами, только опосредованно, через макросы.

#### Советы и рекомендации

С помощью макроса реализуйте модульный способ вызова функции над элементами массива. Сами функции реализуйте отдельно, в виде обычных классических функций (не макросов).
Модульный способ вызова функции печати текста через макрос:

```
#define CALL(func) { func("Hello, GeekBrains!"); }

void print(std::string str) {
std::cout << str << std::endl;
}

int main() {
CALL(print);
return 0;
}
```

Обязательно просмотрите итоговый код после препроцессинга из CLion с помощью Shift-Shift → Preprocess current TU.

#### Что оценивается

Корректность работы программы. Модульность и элегантность решения с помощью макросов.

#### Как отправить работу на проверку

Пришлите файл CPP с решением через форму ниже.

## Урок 6. Работа с датами

### Цели практической работы

1. Получить практический навык работы со временем и датами в C++.
2. Научиться:  
   — запрашивать текущее актуальное время;  
   — получать информацию о дате от пользователя;  
   — выводить даты в нужном формате;  
   — производить простейшие манипуляции со временем.

### Что входит в практическую работу

1. Реализовать программу учёта времени.
2. Реализовать программу напоминания о днях рождения.
3. Реализовать вывод выбранного времени года.

### Общие условия

Разработка выполняется в среде [VS Code](https://code.visualstudio.com/download).

### Задание 1. Реализация программы учёта времени

#### Что нужно сделать

Используя функцию получения текущего времени std::time, реализуйте простейший менеджер учёта времени.  
Пользователь взаимодействует с программой с помощью команд:  
• Команда begin начинает отслеживание новой задачи. После ввода этой команды пользователь должен ввести название задачи, над которой он планирует сейчас работать. Если уже была начата какая-то другая задача, предыдущая должна быть автоматически завершена и начата новая.  
• Команда end заканчивает отслеживание текущей задачи. Если текущей начатой задачи нет, то команда ничего не делает.  
• Команда status выводит на экран информацию о всех законченных задачах и времени, которое было на них потрачено. Также выводится название текущей выполняемой задачи, если таковая имеется.  
• Команда exit выходит из программы.

#### Советы и рекомендации

Тип std::time_t принимайте за секунды и с помощью него рассчитывайте время в часах, которое было затрачено.

#### Что оценивается

Корректность работы программы.

#### Как отправить работу на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

### Задание 2. Реализация программы напоминания о днях рождения

#### Что нужно сделать

Реализуйте простую программу по вычислению ближайшего дня рождения.  
В начале программы пользователь последовательно вводит данные о днях рождения своих друзей: вводит имя друга и саму дату рождения полностью, включая месяц и год, в формате год/месяц/день. Сигналом окончания ввода дней рождения является “end” введённое в качестве имени.
После этого программа вычисляет ближайший день рождения по отношению к текущему времени и выводит его на экран вместе с именем в удобном, локальном формате - месяц/день. Если день рождения уже был в этом году, данные о пользователе пропускаются. Если у кого-то из друзей день рождения сегодня, то в консоль выводится специальное сообщение об этом. Учтите, что таких сообщений может быть несколько, ведь сразу несколько людей могут иметь дни рождения в один день.

#### Советы и рекомендации

Для подсчёта ближайшего дня используйте данные из структуры даты std::tm.

#### Что оценивается

Корректность работы программы.

#### Как отправить работу на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

### Задание 3. Реализация программы таймера

#### Что нужно сделать

Реализуйте работу точного таймера с визуальной отдачей.  
В начале программы пользователь вводит количество минут и секунд, которые требуется засечь на таймере, и нажимает «Ввод».
После этого начинается обратный отсчёт времени, о чём незамедлительно и последовательно сообщается пользователю. Формат вывода такой же, как и при вводе интервала: минуты и секунды.
Как только отсчёт на таймере иссяк, программа сообщает об этом с помощью вывода в консоль специального сообщения. Сообщение вместо аудиосигнала может выглядеть так: DING! DING! DING!

#### Советы и рекомендации

Для ввода значения для засекания времени используйте std::get_time, но в качестве формата запросите только минуты и секунды. Целевое время для остановки таймера вычислите сами с помощью манипуляции над текущим std::time. Количество оставшегося времени выводите в цикле и вычислите его самостоятельно с помощью обращения с типом std::time_t как с секундами.

#### Что оценивается

Корректность работы программы при разных заданных дефинициях макросов.

#### Как отправить работу на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

## Урок 7. Структура проекта

### Цели практической работы

• Приобрести понимание разбиения проекта на исходные и заголовочные файлы.  
• Научиться использовать основные команды CMake.

### Что входит в работу

1. Реализовать симулятор проведения операций.
2. Создать модульный проект симулятора работы компьютера.

Общие условия
Разработка выполняется в среде VS Code.

### Задание 1. Симулятор проведения операций

#### Что нужно сделать

Реализуйте простой симулятор проведения медицинской операции у пациента. Пользователь выступает в роли хирурга, который запрашивает инструменты у ассистента и применяет их сообразно ситуации.  
Пользователь взаимодействует с программой с помощью команд. Команды не имеют сложной встроенной логики: они просто принимают нужные данные в качестве аргументов и выводят сообщения в консоль о выполнении. Данные команд — это одна или две двумерные точки в формате double с координатами X и Y соответственно.  
Команда scalpel — принимает на вход две двумерные координаты начала и конца разреза или линии отсечения. При выполнении в консоль выводится сообщение о том, что был сделан разрез между введёнными координатами.  
Команда hemostat принимает на вход одну точку, в которой требуется сделать зажим, о чём также сообщает в консоль.  
Команда tweezers — пинцет, как и зажим, принимает одну точку для применения. Сообщение об этом выводится в консоль.  
Команда suture — хирургическая игла, которая делает шов между двумя указанными точками.  
Операция всегда начинается с команды scalpel и заканчивается командой suture. Для окончания работы программы их параметры-точки должны совпасть.  
Программу требуется реализовать именно с помощью одного заголовочного файла и одного файла с исходным кодом (CPP). В заголовочном файле должны находиться функции-инструменты. В основном файле — основная логика программы, обработка ввода пользователя.

#### Советы и рекомендации

• Создайте структуру с типом двумерной координаты (точки) вместе с набором функций для ввода этой координаты из консоли, её вывода в консоль и сравнения на предмет равенства. Для этих целей удобнее всего создать ещё один заголовочный файл.  
• Обратите внимание на порядок команд.  
• Заголовочные файлы с расширением .h следует расположить в папке include. Файлы исходного кода с расширением .cpp — в папке src.

#### Что оценивается

• Все команды вводятся пользователем через стандартный ввод.  
• Программа и CMake-файл конфигурации проекта работают корректно.

#### Как отправить работу на проверку

На проверку пришлите архив, содержащий, помимо CPP- и H-файлов, файлы настройки проекта в среде CMake(CMakeLists.txt).

### Задание 2. Проект симулятора работы компьютера

#### Что нужно сделать

Реализуйте простую модель работы персонального компьютера в качестве многомодульного проекта. В компьютере несколько основных, условных компонент.

Центральный процессор (cpu) — должен иметь функцию compute, которая складывает 8 чисел из буфера оперативной памяти (см. далее) и выводит результат в консоль.  
Оперативная память (ram) — содержит буфер на 8 целых чисел, которые можно заполнить функцией write и считать функцией read.  
Жёсткий диск (disk) — имеет в себе две функции, save и load. Функция save должна сохранить состояние 8 чисел из оперативной памяти на постоянный носитель в файл data.txt. Функция load — загрузить их с носителя в оперативную память.  
Графическая карта (gpu) — выводит в консоль 8 чисел из оперативной памяти.  
Клавиатура (kbd) — позволяет ввести 8 чисел и разместить их в оперативной памяти.

Каждая компонента должна располагаться в отдельном модуле, с отдельным заголовочным файлом. Основной модуль программы (main.cpp) должен считывать пользовательский ввод команды, которая соответствует отдельным функциям устройств: sum (вычисление суммы), save (сохранить в файл), load (загрузить из файла), input (ввести с клавиатуры), display (вывести на экран). Команда exit — выходит из программы.

#### Советы и рекомендации

Тщательно продумайте зависимости между модулями и теми файлами, которые должны быть включены в исходные файлы. Не забывайте про #pragma once в заголовочных файлах.  
В заголовочных файлах модулей располагайте только объявления функций. Их определения должны быть уже в исходных файлах (CPP).

#### Что оценивается

• Обращение к буферу оперативной памяти делается только через модуль ram, напрямую доступ к буферу не осуществляется.  
• Программа и составленные CMake-файлы конфигурации проекта работают корректно.  
• Для программы создано два файла CMakeLists.txt, один в основной директории, второй в директории src.  
• В файлах CPP в поле всех #include-директив используется только название файла, не должно быть #include-директив с указанием папки. Не допускается:

```
../include/.. .h
D:/.../include/.. .h
```

#### Как отправить работу на проверку

Пришлите архив, содержащий, помимо CPP- и H-файлов, файлы настройки проекта в среде CMake (CMakeLists.txt).

### Критерии оценки

• Файлы CMakeLists.txt не содержат ошибок.  
• Программы запускаются и корректно работают, нет синтаксических ошибок.  
• Имена переменных корректные, отражают суть хранимых данных.  
• Создан текстовый интерфейс для всех программ.  
• Решения обеих задач структурированы и содержат заголовочные файлы.  
• Выполнено два задания.

## Урок 8. Введение в ООП. Часть 1

### Цели практической работы

1. Получить первичный практический навык работы с классами в C++.
2. Научиться:  
   — объявлять классы,  
   — пользоваться типами доступа,  
   — определять методы класса.

### Что входит в практическую работу

1. Реализовать программу имитации аудиоплеера.
2. Реализовать программу симуляции мобильного телефона.
3. Реализовать программу управления окном рабочего стола.

### Общие условия

Разработка выполняется в среде VS Code.

### Задание 1. Реализация имитации аудиоплеера

#### Что нужно сделать

С помощью классов реализуйте программу имитации работы аудиоплеера. В плеере находится несколько аудиозаписей, доступных для воспроизведения. Для них вы должны создать отдельный класс Track. Полями этого класса должны быть: название, дата создания (здесь вы можете использовать тип std::tm) и продолжительность записи в секундах.
Сам плеер тоже реализуйте с помощью класса. Внутри он должен содержать список доступных записей и нужные для логики работы плеера поля.

Пользователь взаимодействует с программой с помощью команд:

• Команда play запрашивает у пользователя название записи для воспроизведения и начинает её воспроизведение. Воспроизведение симулируется с помощью вывода в консоль всей информации о записи. Если произведение какой-то записи уже начато, ничего не происходит.  
• Команда pause. Ставит запись на паузу, о чём выводит соответствующее сообщение в консоль. Если запись уже на паузе или не воспроизводится вовсе, ничего не происходит.  
• Команда next переходит к следующей записи для воспроизведения. Запись при этом выбирается случайно, как будто плеер работает в режиме shuffle.  
• Команда stop прекращает воспроизведение текущей записи, если таковая имеется. Об этом выводится сообщение в консоль. Два раза остановить воспроизведение невозможно, так что команда должна срабатывать только в первом случае.  
• Команда exit — выход из программы.

#### Советы и рекомендации

Забудьте про отдельные глобальные функции и используйте возможности классов и методов по максимуму.

#### Что оценивается

Корректность работы программы.

#### Как отправить работу на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

### Задание 2. Реализация программы симуляции мобильного телефона

#### Что нужно сделать

Реализуйте программу простой симуляции работы мобильного телефона.
По мобильному телефону можно звонить и отправлять СМС. Также мобильный телефон содержит адресную книгу. Телефон и отдельные записи адресной книги должны быть реализованы с помощью классов. Все номера телефонов задаются в формате +7 <10 цифр>.

Пользователь взаимодействует с программой с помощью команд:

• Команда add добавляет в адресную книгу новый номер телефона и ассоциирует его с именем контакта. Оба эти параметра команда получает от пользователя через стандартный ввод.  
• Команда call запрашивает у пользователя имя контакта или номер телефона, на который требуется позвонить. Сам по себе звонок симулируется с помощью вывода в консоль сообщения CALL с номером телефона, на который осуществляется вызов.  
• Команда sms. Запрашивает у пользователя номер телефона (или имя контакта), на который требуется послать сообщение. Само сообщение также вводится через стандартный ввод.  
• Команда exit — выход из программы.

#### Советы и рекомендации

Сам по себе тип номера телефона вы тоже можете реализовать с помощью отдельного класса.

#### Что оценивается

Корректность работы программы.

#### Как отправить работу на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

### Задание 3. Реализация программы управления окном рабочего стола

#### Что нужно сделать

Реализуйте симуляцию работы окна в визуальном интерфейсе пользователя.
Окно располагается на виртуальном экране монитора, размером 80 × 50 точек. У окна есть несколько параметров, которые также задаются в пикселях: двумерные координаты левого верхнего угла и размеры, ширина и высота. Ширина и высота при этом не могут быть отрицательными, а координаты не могут выходить за область экрана.

Пользователь взаимодействует с программой с помощью команд:

• Команда move принимает вектор, на который надо сместить окно на экране. Сообщение с новыми координатами окна появляется на экране.  
• Команда resize запрашивает из стандартного ввода новый размер окна. После изменения размера сообщение с новым размером выводится на экране.  
• Команда display выводит текущее изображение монитора в консоль. 0 — это пиксель вне области окна, 1 — с окном.  
• Команда close закрывает окно, выход из программы.

#### Советы и рекомендации

Сам экран монитора вы тоже можете реализовать с помощью класса.

#### Что оценивается

Корректность работы программы и изменений позиции и размеров окна при различном пользовательском вводе.

#### Как отправить работу на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.
