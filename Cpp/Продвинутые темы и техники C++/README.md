# Продвинутые темы и техники C++

## Урок 1. Чтение из файлов

### Цели практической работы

Приобрести практическое понимание работы с файлами.

#### Научиться:

• открывать файлы по указанному пути,  
• считывать разные типы данных из текстовых файлов,  
• считывать данные из бинарных файлов,  
• составить простейшие текстовые данные в редакторе,  
• считывать массивы данных.

### Что входит в практическую работу

1. Разработать программу поиска слов в файле.
2. Разработать простейший просмотрщик текстовых файлов.
3. Реализовать программу чтения и анализа ведомости с выплатами.
4. Разработать детектор PNG-файла.
5. Реализовать версию игры «Что? Где? Когда?».

### Общие условия

Разработка выполняется в среде VS Code. Текстовые документы можно редактировать в стандартном блокноте.

### Задание 1. Разработка программы поиска слов в файле

#### Что нужно сделать

Составьте небольшой текстовый файл «words.txt», в котором последовательно, через пробелы и переносы строк расположены различные слова. Можете использовать любые англоязычные слова. Разработайте программу, которая искала бы среди этих слов нужное пользователю и выводила бы общее количество повторений этого слова. 0 — если слово вообще не присутствует в файле.

#### Что оценивается

Корректность работы программы на созданных вами вводных данных. Число найденных слов должно соответствовать.

#### Как отправить работу на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 2. Разработка просмотрщика текстовых файлов

#### Что нужно сделать

Разработайте простейший просмотрщик текстовых файлов. В начале программы пользователь вводит путь к текстовому файлу, который требуется открыть и просмотреть. Внутренности файла необходимо вывести в стандартный вывод. Программа должна работать для любых текстовых файлов в формате TXT, но вы можете создать и свой отдельный файл для теста. Главное, чтобы файл был англоязычным, дабы избежать проблем с кодировками.

#### Советы и рекомендации

• Для проверки того, был ли на самом деле открыт файл, используйте метод is_open. Он вернёт true, если файл был благополучно открыт, и false, если что-то пошло не так, к примеру, если путь к файлу невалидный.  
• Файл надо считывать постепенно, отдельными фрагментами, ведь он может быть весьма большим. Для этого лучше всего пользоваться методом gcount, так как он ещё вернёт количество байт, которые были считаны по факту методом read. Сами эти фрагменты могут храниться в специальном буфере, как и в примере из лекций, но его размер и второй аргумент к функции read надо рассчитать так, чтобы выводились все символы, без обрезки последней буквы.  
• Файл можно открыть в бинарном формате.

#### Что оценивается

Показ файла на экране должен соответствовать тому, что мы наблюдаем в стандартном блокноте.

#### Как отправить работу на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 3. Реализация программы чтения ведомости

#### Что нужно сделать

Реализуйте программу чтения информации из ведомости по учёту выплат. Сама ведомость представляет собой следующую таблицу:  
• имя и фамилия человека;  
• количество денег, которые были выплачены лицу;  
• дата выплаты в формате ДД.ММ.ГГГГ.

На основе данных из ведомости следует подсчитать общее количество выплаченных средств и определить человека с максимальной суммой выплат.  
Пример данных ведомости

```
Tom Hanks 35500 10.11.2020
Rebecca Williams 85000 1.1.2021
Sally Field 15600 15.8.2021
Michael Humphreys 29400 23.5.2020
Harold Herthum 74300 9.6.2019
George Kelly 45000 12.3.2018
Bob Penny 12500 13.5.2020
John Randall 23400 2.10.2020
Sam Anderson 6500 15.7.2020
Margo Moorer 12350 24.2.2019ш
```

#### Что оценивается

Корректное отображение общей суммы выплат и самого крупного получателя денежных средств.

#### Как отправить работу на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 4. Разработка детектора PNG-файла

#### Что нужно сделать

Разработайте программу, которая получает на вход, в стандартный ввод, путь к файлу. На выходе программа должна определить, является ли данный файл PNG-изображением. Данная процедура не просто должна смотреть на расширение файла, но и произвести минимальный анализ его внутренностей, в бинарном режиме.
Внутренности валидного бинарного файла начинаются со специального 8-байтового заголовка. Нас будут интересовать первые четыре байта. Первый байт всегда имеет значение −119 (число со знаком минус), а следующие — это просто символы ‘P’, ‘N’, ‘G’, расположенные друг за другом. Обратите внимание, что все они в верхнем регистре.
По результатам проверки пути и внутренностей требуется сообщить пользователю о результате проверки в стандартный вывод.

#### Советы и рекомендации

Чтобы определить расширение файла, используйте функцию substr, которая получает офсет и длину подстроки и возвращает её.

#### Что оценивается

Для произвольных путей файлов, введённых пользователем, требуется выдавать корректный результат — являются ли они PNG-файлами или нет.

#### Как отправить работу на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 5. Реализация игры «Что? Где? Когда?»

#### Что нужно сделать

Реализуйте простую версию интеллектуальной игры «Что? Где? Когда?».  
Как происходит игра  
В начале каждого хода игроки вращают волчок, то есть выбирают сектор на столе, который сейчас играет. Всего таких секторов 13. Сектор выбирается так: с клавиатуры вводится офсет (смещение) относительно текущего сектора на барабане. Исходя из этого офсета вычисляется новый активный сектор, который и будет играть в этом ходе. Если выпавший сектор уже играл, выбирает следующий не игравший за ним. В начале всей игры стрелка установлена на первом секторе.

Как только играет какой-то из секторов, с него берётся письмо с вопросом — то есть считывается из файла данного сектора. Вопрос показывается на экране.  
После того как вопрос показан, от игрока ожидается ответ на него. Игрок вводит этот ответ с помощью стандартного ввода. То, что он ввёл, сравнивается с ответом, который хранится во втором файле, ассоциированном с активным сектором. Данный файл должен содержать лишь одно слово-ответ.

Если ответ знатока-игрока был правильным, ему начисляется один балл. Если неверен, то балл уходит телезрителям.  
Игра продолжается до тех пор, пока или игрок, или зрители не наберут шесть баллов. После этого называется победитель и программа заканчивает работу.

#### Что оценивается

Игра должна корректно работать от первого хода до последнего. В результате обязательно должен выявляться победитель.

#### Как отправить работу на проверку

Прислать ссылку на repl.it или файл .срр с решением.

## Урок 2. Запись в файлы

### Цели домашнего задания

Приобрести практическое понимание работы с файлами.

#### Научиться:

• открывать файлы на запись по указанному пути и закрывать их;  
• записывать разные типы данных в файлы;  
• записывать массивы данных в файлы;  
• пользоваться генератором случайных чисел.

### Что входит в домашнее задание

1. Реализовать запись в ведомость учёта.
2. Реализовать рисование случайных картин.
3. Реализовать симуляцию игры «Рыбалка».
4. Реализовать симуляцию работы банкомата.

### Общие условия

Разработка выполняется в среде [CLion](https://www.jetbrains.com/clion). Текстовые документы можно редактировать в стандартном блокноте.

### Задание 1. Реализация записи в ведомость учёта

#### Что нужно сделать

В одном из прошлых заданий мы уже создавали программу чтения и анализа ведомости выплат. Теперь требуется создать простую программу записи в эту ведомость.
Формат ведомости прежний. Сначала идёт имя и фамилия получателя денежных средств, далее располагается дата выдачи в формате ДД.ММ.ГГГГ. Завершает запись сумма выплаты в рублях. Данные разделяются между собой пробелами. В конце каждой записи должен быть расположен перевод строки.  
При старте программы пользователь последовательно вводит данные для новой записи, которые записываются затем в файл в текстовом режиме. Программа должна добавлять новые записи в конец файла, не удаляя его текущее содержимое.

#### Советы и рекомендации

Введённые данные рекомендуется хотя бы минимально валидировать перед их записью.
Для валидации даты в указанном формате можно использовать функции std::stoi и std::subtr с корректно указанным диапазоном символов в дате. К примеру, вызов std::stoi(date.substr(3, 2)) вычленит из строковой даты целочисленный месяц для последующего анализа.

#### Что оценивается

Корректность работы программы. Программа должна дозаписывать данные в конец существующего списка.

#### Как отправить задание на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 2. Реализация рисования случайных картин

### Что нужно сделать

С помощью генератора случайных чисел рисуется картинка из нулей и единиц. На вход от пользователя принимается размер картины: высота и ширина в пикселях. На выходе нужно создать файл pic.txt, содержимое которого будет наполнено случайными нулями и единицами в рамках размера картины.  
Это ещё не всё. Если вы запустите программу несколько раз на одних и тех же исходных данных (ширина и высота картины), вы очень скоро обнаружите, что всё время выводится одна и та же картинка. Дело в том, что у генератора случайных чисел есть ещё и «зерно», от которого он отталкивается. Если это зерно не меняется, то и серия из rand() всегда будет возвращать одни и те же случайные числа.  
Чтобы разнообразить вывод, вы можете использовать вызов std::srand(std::time(nullptr)); в самом начале программы. Эта операция задаёт начальное зерно случайных чисел в зависимости от текущего времени. Для её корректной работы не забудьте также включить заголовочный файл <ctime>.

#### Что оценивается

Корректность работы программы по созданию случайных изображений заданного размера.

#### Как отправить задание на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 3. Реализация симуляции игры «Рыбалка»

#### Что нужно сделать

Реализуйте простую симуляцию игры в рыбалку. В исходном текстовом файле реки (river.txt) задаётся список из видов рыб, которые можно в ней поймать. Рыбок может быть сколько угодно, разных видов. Виды при этом могут повторяться.  
В начале программы пользователь указывает, какую именно рыбу он сейчас будет ловить — вид этой рыбы. После этого из первого файла друг за другом осуществляется чтение его содержимого, вид за видом. Если на отдельных шагах вид совпал с указанным пользователем, в выходной файл basket.txt (корзинка) записывается этот вид.  
В конце программы показывается, сколько было поймано рыб за текущую ловлю. Программу можно запускать несколько раз, при этом уже пойманные рыбы должны сохраняться в файле-корзинке.  
Пример содержания исходного файла

```
sunfish
shad
carp
bass
bullhead
carp
walleye
catfish
carp
```

#### Что оценивается

Корректность работы программы симуляции игры в рыбалку. Пойманные рыбы должны записываться в выходной файл.

#### Как отправить задание на проверку

Прислать ссылку на repl.it или файл .срр с решением.

### Задание 4. Реализация симуляции банкомата

#### Что нужно сделать

Требуется реализовать упрощённую симуляцию работы банкомата. В банкомате могут храниться только бумажные купюры номиналом от 100 до 5000 рублей. Максимально в банкомате может храниться только 1000 купюр. Все они записываются в отдельный файл. У банкомата, как у устройства, две основных операции — снятие денег пользователем и наполнение деньгами инкассаторами банка.

Наполнение банкомата происходит, если при старте программы в консоль вводится символ плюс “+”. Количество купюр рассчитывается так, чтобы банкомат был заполнен полностью. Все купюры при этом выбираются случайным образом.  
Если на старте программы в консоль вводится минус (“-”), то симулируется снятие пользователем денег. Пользователь указывает сумму с точностью до 100 рублей. Мы будем считать, что каждый клиент обладает неограниченным балансом в системе и теоретически может снять любую сумму. На практике, если данная сумма не может быть снята из-за отсутствия подходящих денег в машине, показывается сообщение, что эта операция невозможна.  
После выполнения любой из операций программа завершает выполнение. Состояние банкомата должно храниться в отдельном бинарном файле, автономно.

#### Советы и рекомендации

Вы можете хранить массив купюр целиком, помечая отсутствующие позиции нулями.

#### Что оценивается

Корректность работы программы симуляции банкомата. Инкассация и снятие денег должны работать корректно.

#### Как отправить задание на проверку

Прислать ссылку на repl.it или файл .срр с решением.

## Урок 3. Структуры данных

В практической работе есть обязательные задачи и дополнительное задание.
Обязательные задачи помогут понять, как вы усвоили материал модуля. Их нужно сдать на проверку куратору.
Дополнительное задание подойдёт тем, кто хочет ещё немного потренироваться, решая задачки по программированию. Вы также можете отправить его на проверку и получать обратную связь куратора.

### Цели практической работы

Вы потренируетесь работать со структурами данных:  
• объявлять и инициализировать структуры;  
• считывать и записывать их поля;  
• заводить массивы.

### Что входит в практическую работу

1. Ведомость учёта.
2. Модель данных для посёлка.
3. Математический вектор.
4. Пошаговая ролевая игра (дополнительное задание).

Разработку нужно выполнить в среде [VS Code](https://code.visualstudio.com/download). Текстовые документы можно редактировать в стандартном блокноте.

### 1. Ведомость учёта

#### Что нужно сделать

Вы уже создавали программу чтения и записи ведомости. Теперь её нужно обобщить и дополнить использованием структур.  
Формат ведомости прежний:  
• сначала — имя и фамилия получателя денег,  
• далее — дата выдачи в формате ДД.ММ.ГГГГ,  
• затем — сумма выплаты в рублях.  
Данные разделяются пробелами. В конце каждой записи должен быть перевод строки. Структура данных должна соответствовать этому формату.

При старте программы пользователь отправляет команду: list или add. Команда list осуществляет чтение из файла ведомости, как и прежде, только уже в структуры данных, и отображает их на экране.  
Команда add добавляет новую запись в конец ведомости.

#### Советы и рекомендации

• Чтобы определить, где заканчивается файл, используйте функцию file.eof().  
• Из-за завершающего переноса строки при чтении данных из файла стоит отдельно прочитать имя получателя денег. Если после чтения имени получателя денег признак file.eof() принял значение true, значит, файл закончился.  
• Используйте вектор структур. Для выбора команды потребуется подобная конструкция:

```
if (command == "list")
{
…
}
```

### 2. Модель данных для посёлка

#### Что нужно сделать

Используя структуры данных, создайте подробную модель посёлка.  
Что известно  
• Посёлок состоит из участков, и у каждого участка есть свой номер.  
• На любом участке может стоять жилой дом, а также могут быть и другие сооружения:  
— гараж,  
— сарай (бытовка),  
— баня.  
• У каждого здания есть информация о площади, которую оно занимает на участке.  
• В доме может быть 1–3 этажа, на этаже — 2–4 комнаты:  
— спальня,  
— кухня,  
— ванная,  
— детская,  
— гостиная.  
• У каждого этажа есть информация о количестве комнат и высоте потолка на этаже.  
• У каждой комнаты есть информация о занимаемой площади.  
• В доме и бане может быть печь с трубой.  
Для всех упомянутых сущностей нужно объявить структуры данных.

#### Обязательно для выполнения задания

Опишите структуры данных для создания модели посёлка. Структуры должны быть:  
• связными и легко расширяемыми,  
• без дублирующих конструкций.

#### Дополнительно

Реализуйте заполнение структур данных.  
Пользователь заполняет данные о посёлке: вводит общее количество участков, а потом детализирует каждый.  
Сначала указывается количество построек на участке, а затем — информация, какие это постройки, сколько этажей в доме, какие комнаты на этажах.  
После ввода данных можно рассчитать суммарный параметр, например процент земли, занимаемой постройками, от общей площади посёлка. Главное в этой задаче не операция подсчёта, а структуры данных.

#### Советы и рекомендации

• Используйте свои знания о типах данных в C++.  
• Можно применять перечисления и векторы, создавать структуры внутри структур и так далее.  
• Перечислять комнаты и типы зданий нужно следующим образом:

```
enum room_type
{
living,
children,
…
```

• Затем нужно использовать полученный тип внутри структуры. Алгоритм заполнения каждого объекта одинаковый:  
— создать объект нужного типа,  
— ввести с клавиатуры значения,  
— добавить объект в вектор при помощи push_back.

### 3. Математический вектор

#### Что нужно сделать

Реализуйте структуру двумерного математического вектора и основные операции над ним. Обе координаты вектора (x и y) должны быть вещественными числами.  
Начиная работу с программой, пользователь вводит команду. Затем в зависимости от команды пользователь вводит аргументы. Это могут быть как векторы, так и обычные скалярные значения. Результат помещается в стандартный вывод. Это тоже может быть или вектор, или скаляр.

Реализуйте в виде отдельных функций операции:  
• сложение двух векторов — команда add;  
• вычитание двух векторов — команда subtract;  
• умножение вектора на скаляр — команда scale;  
• нахождение длины вектора — команда length;  
• нормализация вектора — команда normalize.

#### Советы и рекомендации

Для выбора команды используйте конструкцию вида if (operation == "add"). Тут так и напрашиваются отдельные функции для каждой операции.

### 4. Пошаговая ролевая игра (дополнительное задание)

#### Что нужно сделать

Реализуйте упрощённую версию пошаговой ролевой игры.  
Действие разворачивается на карте размером 20 на 20 клеток. По клеткам перемещаются игрок и его противники.  
После каждого хода игрока карта показывается вновь со всеми противниками на ней:  
• игрок помечается буквой P,  
• противники — буквой E,  
• пустые места — точкой.  
Каждый персонаж игры представлен в виде структуры с полями:  
• «Имя»,  
• «Жизни»,  
• «Броня»,  
• «Урон».  
Сначала создаётся пять противников в случайных клетках карты:  
• Имена противникам задаются в формате Enemy #N, где N — порядковый номер.  
• Уровень жизни противников задаётся случайно — от 50 до 150.  
• Уровень брони варьируется от 0 до 50.  
• Урон тоже выбирается случайно — от 15 до 30 единиц.  
Игрок конструирует своего персонажа самостоятельно. Задаёт все его параметры, включая имя. Все персонажи появляются в случайных местах карты.  
Игрок ходит с помощью команд: L, R, U, D (по первым буквам слов left, right, up, down). В зависимости от команды выбирается направление перемещения: влево, вправо, вверх, вниз.  
Противники перемещаются в случайном направлении.  
Если игрок перемещается в сторону, где уже кто-то находится, он наносит этому персонажу урон. Противники при этом никогда не бьют друг друга: они просто пропускают ход и остаются на своём месте. За пределы карты (20 на 20 клеток) ходить нельзя никому. Если кто-то выбрал направление за границами, ход пропускается.
Формула расчёта урона совпадает с той, что была в материале. Жизни уменьшаются на размер урона. При этом броня тоже сокращается на приведённый урон.
Игра заканчивается тогда, когда умирают либо все противники, либо игрок. В первом случае на экран выводится сообщение о победе, во втором — о поражении.
Если в начале хода игрок вводит команду save или load вместо направления перемещения, то игра либо сохраняет своё состояние в файл, либо загружает это состояние из файла.

#### Советы и рекомендации

• Для определения команды персонажа можно внутри структуры данных о нём завести флаг.  
• Для отображения координат персонажей можно использовать структуру вектора из другой задачи, но заменить типы координат.  
• Для сохранения параметров игры и их загрузки можно работать с текстовыми данными. Однако записать всё в двоичном формате проще, главное — соблюдать последовательность полей:

```
std::ofstream file("save.bin", std::ios::binary);
for (int i = 0; i < 6; ++i) {
file.write((char\*)&(characters[i].position),
sizeof(characters[i].position));
…
```

• При загрузке используйте ifstream и ту же последовательность полей.

Задание необязательно сдавать на проверку. Но если хотите это сделать, куратор будет учитывать следующее:  
• Корректно работает сохранение и загрузка в игре.  
• После загрузки все атрибуты игрока, включая имя, восстанавливаются из файла.  
• После загрузки количество противников на поле соответствует количеству противников при сохранении.  
• Все игроки после загрузки появляются в местах, где они находились при сохранении.  
• При ходе игрока не появляются новые противники.  
• Перед загрузкой файла сохранения проверяется, есть ли он в операционной системе.

#### Что оценивается

• Программы запускаются и корректно работают, нет синтаксических ошибок.  
• Имена переменных корректные, отражают суть хранимых данных.  
• Создан текстовый интерфейс для всех программ.  
• Во всех задачах корректно использованы структуры.  
• Перед загрузкой файла в задачах проверяется его существование на диске.  
• Выполнено минимум три задания.

#### Как отправить работу на проверку

Пришлите ссылку на Repl.it или файлы CPP (для каждого задания нужен отдельный) с решением через форму ниже.

## Урок 4. Словари std::map

### Цели домашнего задания

• Приобрести навыки работы с std::map.  
• Научиться вставлять, удалять и искать элементы.  
• Научиться использовать итераторы для прямого прохода по контейнеру.

### Что входит в задание

1. Написать программу «Телефонный справочник».
2. Написать программу «Регистратура».
3. Написать функцию, которая выводит анаграмму.

### Задание 1. Телефонный справочник

#### Что нужно сделать

Напишите программу «Телефонный справочник».  
На вход программе поступают запросы трёх типов:  
69-70-30 Ivanov — добавить телефон и фамилию абонента в справочник  
69-70-30 — узнать фамилию абонента по номеру телефона  
Ivanov — узнать телефон абонента по фамилии  
Необходимо выводить в консоль ответ на запросы 2 и 3. Обратите внимание, что абоненты по разным номерам могут иметь одинаковые фамилии. В таком случае на запрос 3 необходимо выдать все номера через пробелы.  
Операции запросов должны работать за O(logn) или O(logn × количество номеров с этой фамилией).

#### Чек-лист для проверки задачи

• Программа корректно выводит фамилии и списки номеров.  
• Программа использует только заголовочные файлы <iostream>, <string>, <map> и, возможно, вектор.

#### Как отправить задание на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

### Задание 2. Регистратура

#### Что нужно сделать

Напишите программу «Регистратура».  
На вход программе приходят строки с фамилиями или строка Next. Пришедшие люди становятся в очередь, а по запросу Next необходимо вызвать в регистратуру человека с фамилией, идущей первой в лексикографическом порядке (по алфавиту), и вывести его фамилию на экран. Фамилии пациентов могут повторяться.  
Каждый запрос (на добавление и вывод) должен работать за O(logn).

Пример:

```
← Sidorov
← Ivanov
← Ivanov
← Petrov
← Next
→ Ivanov
← Next
→ Ivanov
← Next
→ Petrov
```

#### Чек-лист для проверки задачи

• Программа корректно выводит фамилии в лексикографическом порядке.  
• Программа использует только заголовочные файлы <iostream>, <string>, <map>.

#### Как отправить задание на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.

### Задание 3. Анаграммы

#### Что нужно сделать

Напишите функцию, которая принимает две строки и возвращает true, если первая строка является анаграммой второй (то есть можно получить первую строку из второй путём перестановки букв местами), и false иначе. Для достижения хорошей асимптотики решения рекомендуется использовать std::map.  
Пример анаграммы: лекарство — стекловар

#### Чек-лист для проверки задачи

• Функция принимает корректные типы данных, тип возвращаемого значения — bool.  
• Функция не использует библиотек, кроме <iostream>, <map>, <string>.  
• Функция корректно определяет, являются ли строки анаграммами.

#### Как отправить задание на проверку

Пришлите ссылку на repl.it или файл .срр с решением через форму для сдачи домашнего задания.
